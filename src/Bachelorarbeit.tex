\newcommand{\DeinName}{Pascal Fischer}
\newcommand{\MatrNo}{371778}
\newcommand{\TitelArbeit}{Entwicklung einer verschlüsselten Chat-basierten Plattform auf Basis des Matrix.org-Protokolls im Kontext von digitaler Gesundheit und Telemedizin}
\newcommand{\Fachgebiet}{Regelungssysteme}
\newcommand{\PrueferEins}{Dr.-Ing Thomas Schauer}
\newcommand{\PrueferZwei}{Prof.-Dr.-Ing. Clemens Gühmann}
\newcommand{\fachbereich}{Elektrotechnik und Informatik}

% entweder ein Datum h?ndisch eintragen, oder den Befehl \today nutzen
\newcommand{\Datum}{\today}

\makeglossary


%
% Einbinden des Headers, hier k?nnen auch weitere Einstellungen vorgenommen werden.
\input{source/header}

\graphicspath{ {./source/images/pictures/} }

\lstdefinelanguage{json}{
    numbers=left,
    numberstyle=\small,
    frame=single,
    rulecolor=\color{black},
    showspaces=false,
    showtabs=false,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{gray}\hookrightarrow\space}},
    breakatwhitespace=true,
    basicstyle=\ttfamily\small,
    upquote=true,
    morestring=[b]",
    stringstyle=\color{string},
    literate=
    *{0}{{{\color{numb}0}}}{1}
        {1}{{{\color{numb}1}}}{1}
        {2}{{{\color{numb}2}}}{1}
        {3}{{{\color{numb}3}}}{1}
        {4}{{{\color{numb}4}}}{1}
        {5}{{{\color{numb}5}}}{1}
        {6}{{{\color{numb}6}}}{1}
        {7}{{{\color{numb}7}}}{1}
        {8}{{{\color{numb}8}}}{1}
        {9}{{{\color{numb}9}}}{1}
        {\{}{{{\color{delim}{\{}}}}{1}
        {\}}{{{\color{delim}{\}}}}}{1}
        {[}{{{\color{delim}{[}}}}{1}
        {]}{{{\color{delim}{]}}}}{1},
}


\newcommand\YAMLcolonstyle{\color{red}\mdseries}
\newcommand\YAMLkeystyle{\color{black}\bfseries}
\newcommand\YAMLvaluestyle{\color{blue}\mdseries}

\makeatletter

% here is a macro expanding to the name of the language
% (handy if you decide to change it further down the road)
\newcommand\language@yaml{yaml}

\expandafter\expandafter\expandafter\lstdefinelanguage
\expandafter{\language@yaml}
{
    keywords={true,false,null,y,n},
    keywordstyle=\color{darkgray}\bfseries,
    basicstyle=\YAMLkeystyle,                                 % assuming a key comes first
    sensitive=false,
    comment=[l]{\#},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{purple}\ttfamily,
    stringstyle=\YAMLvaluestyle\ttfamily,
    moredelim=[l][\color{orange}]{\&},
    moredelim=[l][\color{magenta}]{*},
    moredelim=**[il][\YAMLcolonstyle{:}\YAMLvaluestyle]{:},   % switch to value style at :
    morestring=[b]',
    morestring=[b]",
    literate =    {---}{{\ProcessThreeDashes}}3
        {>}{{\textcolor{red}\textgreater}}1
        {|}{{\textcolor{red}\textbar}}1
        {\ -\ }{{\mdseries\ -\ }}3,
}

% switch to key style at EOL
\lst@AddToHook{EveryLine}{\ifx\lst@language\language@yaml\YAMLkeystyle\fi}
\makeatother

\newcommand\ProcessThreeDashes{\llap{\color{cyan}\mdseries-{-}-}}


% Beginn des Dokuments
\begin{document}

%Zitiert alle Referenzen, ohne Sie hier zu listen. Dadurch erscheinen alle Quellen im %Literaturverzeichnis, auch wenn sie im Text nicht genutzt werden.
%Bitte nur f?r Testzwecke verwenden.
    \nocite{*}


% Einbinden des Deckblatts

    \frontmatter
    \include{source/Titelseite}
    \hypersetup{pageanchor=false}

    \newpage
    \section*{Zusammenfassung}
    In dieser Arbeit befasst sich mit ....

    \section*{Abstract}\label{sec:abstract}
    This paper describes how to ...
    \newpage
    \chapter*{Eidesstattliche Erklärung}\label{ch:eidesstattliche-erklarung}
    Hiermit erkläre ich, dass ich die vorliegende Arbeit selbstständig und eigenhändig sowie ohne
    unerlaubte fremde Hilfe und ausschließlich unter Verwendung der aufgeführten Quellen und
    Hilfsmittel angefertigt habe.\\
    \vspace{1cm}\\
    Berlin, den \underline{\hspace{3cm}} \hfill \DeinName \underline{\hspace{4cm}}

    \newpage
    \tableofcontents

    \mainmatter

    \newpage
    \chapter{Einleitung}\label{ch:einleitung}

    \section{Motivation}\label{sec:motivation}
    Die Digitalisierung findet immer Einzug in unser alltägliches Leben, so auch in der Medizin.
    Besonders seit Beginn der Coronapandemie im Jahr 2019 werden Rufe nach Softwarelösungen für den Einsatz in der Telemedizin immer lauter.
    Da viele gängige Messenger wie Whatsapp oder Telegramm nicht den Datenschutz Vorschriften der DSGVO entsprechen müssen hierfür Alternativen geschaffen werden.\\
    \#Todo


    \newpage
    \section{Zielsetzung}\label{sec:zielsetzung}
    Ziel dieser Arbeit ist es eine Plattform zu entwickeln welchen es Ärzten und Patienten ermöglicht in Kontakt zu treten und Nachrichten auszutauschen.
    Hierfür soll eine Chat-App auf basis des Matrix.org-Protokolls implementiert werden.
    Die App ist in der Programmiersprache Swift zu entwickeln und soll auf allen gängigen iOS Geräten unterstützt werden.
    Darüber hinaus muss die benötigte Infrastruktur bereitgestellt werden um Nachrichten und Daten zu speichern und zu übermitteln.
    Diese soll jedoch isoliert laufen und nicht an das existierende Matrix Netzwerk angeschlossen werden.
    Da medizinische Daten dem Datenschutz in besonderer Maße unterliegen ist es besonders wichtig,
    dass jegliche Art von Kommunikation zwischen Ärzten und Patienten stets verschlüsselt ist.
    Es muss gewährleistet sein, dass zu jedem Zeitpunkt alle personenbezogenen Daten vor dem Zugriff unerlaubter Dritter geschützt sind.
%    Da es im Bereich der Medizin  hinaus ist zu beachten, dass das Userinterface
%    So sollte beispielsweise darauf geachtet werden, dass Da es im Bereich der Medizin hinaus ist zu beachten, dass das Userinterface
%    So sollte beispielsweise darauf geachtet werden, dass

    \section{Aufbau der Arbeit}\label{sec:aufbau-der-arbeit}
    Zuerst werden die Theoretischen Grundlagen die für die Entwicklung der Plattform von bedeutung sind erläutert.
%    Zuerst werden die gesetzlichen Ansprüche an eine Messaging-Plattform im medizinischen Bereich beleuchtet.
%    Anschließend wird das Matrix Protokoll vorgestellt und seine allgemeine Funktionsweise beschrieben.
%    Außerdem werden die zur Verschlüsselung verwendeten Algorithmen erklärt und die dafür benötigten Schlüssel aufgezeigt.
    Es werden die zur Implementierung der Plattform genutzten Technologien vorgestellt und deren Verwendung beschrieben.
    Danach werden einige ähnlicher Projekte vorgestellt und analysiert.
    Basierend auf dieser Analyse werden eine eine Reihe von technischen Anforderungen definiert welche von der implementierten Plattform erfüllt werden sollen.
    Anschließend wird die implementierte Plattform vorgestellt und deren Funktionsweise erklärt.
    Abschließend wird die Plattform unter betrachtung der definierten Anforderungen evaluiert.

    \newpage
    \chapter{Theoretische Grundlagen}\label{ch:theoretische-grundlagen}
    In diesem Kapitel werden zunächst die theoretischen Grundlagen, welche die Implementierung der Plattform beeinflusst haben, vermittelt.
    Zuerst werden die gesetzlichen Ansprüche an eine Messaging-Plattform im medizinischen Bereich beleuchtet.
    Anschließend wird das Matrix Protokoll vorgestellt und seine allgemeine Funktionsweise beschrieben.
    Außerdem werden die zur Verschlüsselung verwendeten Algorithmen erklärt und die dafür benötigten Schlüssel aufgezeigt.
    Es wird das REST Paradigma vorgestellt, welches die Grundlage für die Kommunikation zwischen Client und Server bildet.
    Des weiteren wird die MVVM Architektur erläutern, welche bei der Entwicklung der App verfolgt wurde.

    \section{Datenschutz im Gesundheitswesen}\label{sec:datenschutz-im-gesundheitswesen}
    Die Rechtlichen Rahmenbedingungen für das Speicher und Verarbeiten medizinischer Daten sind in der EU-Datenschutz-Grundverordnung\footnote{https://dsgvo-gesetz.de/} (DSGVO) festgelegt.
    Diese fordert ebenfalls zur Einhaltung des IT-Sicherheitsgesetzes und des E-Health-Gesetzes auf.
    Medizinische Daten werden vom Gesetzgeber im besonderem Maße geschützt, da sie besonders sensible Informationen enthalten~\cite{datenschutzimgesundeitswesen}.

    \textit{Das am 29. Dezember 2015 in Kraft getretene "Gesetz für sichere digitale Kommunikation und Anwendungen im Gesundheitswesen (E-Health-Gesetz)" hat die ersten Weichen für den Aufbau der sicheren Telematikinfrastruktur (TI) und die Einführung medizinischer digitaler Anwendungen gestellt.
    Ziel dieses Gesetzes war es, die Chancen der Digitalisierung für die Gesundheitsversorgung zu nutzen und eine schnelle Einführung medizinischer Anwendungen für die Patientinnen und Patienten zu ermöglichen.}~\cite{ehealthgesetz}

    Ein Teil der Telematikinfrastruktur ist der TI-Messenger der Gematik GmbH welcher im Abschnitt~\ref{subsec:ti-messenger} genauer betrachtet wird.\\
    Am 07.11.2019 hat dann die Konferenz der unabhängigen Datenschutzaufsichtsbehörden des Bundes und der Länder ein Whitepaper veröffentlicht welche die \("\)Technischen Datenschutzanforderungen an Messenger-Dienste im\linebreak
    Krankenhausbereich\("\) aus Sicht der DSGVO ~\cite{datenschutzkonferenz} offenlegt.
    Einige dieser Anforderungen sind:
    \begin{enumerate}[label={(\arabic*)}]
        \item Die Applikation muss über die Möglichkeit verfügen, die Nutzung bzw. den Zugriff
    auf die darüber gespeicherten Daten an eine eigene vorherige Authentifizierung (z.B.
    PIN, Fingerabdruck etc.) zu knüpfen
        \item Die Applikation muss über die Möglichkeit verfügen, Kontaktdaten von
    Kommunikationsteilnehmern in einem eigenen, vom allgemeinen Adressbuch des
    Smartphones getrennten Speicher abzulegen.
        \item Sie muss weiterhin über die Möglichkeit verfügen,
    Nachrichten sowie Dateianhänge wie Bilder, Videos, Dokumente etc. ausschließlich
    in einem eigenen, von den allgemeinen Speicherbereichen des Smartphones
    getrennten Speicher in verschlüsselter Form abzulegen
        \item Eine Kommunikation über die Messenger-Applikation sollte nur auf
    der Grundlage einer verlässlichen Identifizierung und Authentifizierung der
    Kommunikationspartner möglich sein
        \item Werden elektronische Signaturen oder andere elektronischer Zertifikate genutzt,
    muss ein Zertifikatsmanagement vorhanden sein. Dies beinhaltet die Sicherstellung,
    dass elektronische Schlüssel oder Zertifikate eindeutig einer juristischen oder
    natürlichen Person zugeordnet werden, aber auch die Überprüfung der Gültigkeit der
    elektronischen Schlüssel bzw. Zertifikate. Insbesondere müssen kompromittierte
    Schlüsseln bzw. Zertifikate bzw. unbrauchbar gemacht werden können
        \item Die Applikation muss über die Möglichkeit verfügen, die über sie verwalteten Daten
    gezielt oder allgemein zu löschen.
        \item Soweit die Speicherung unter Einhaltung von Art. 28 DS-GVO durch einen Dienstleister übernommen wird, welcher nicht die Anforderungen des Art. 9 Abs. 3 DS-GVO erfüllt,
    muss die Möglichkeit bestehen, die Daten nach dem Stand der Technik vor ihrer
    Übergabe derart zu verschlüsseln, dass eine Entschlüsselung nur mit einem
    Schlüssel möglich ist, der nicht an den Dienstleister offenbart und separat gesichert
    wird.
        \item Die Vertraulichkeit und Integrität der über den Messenger-Dienst geführten
    ärztlichen Kommunikation muss unter Berücksichtigung des Stands der Technik
    über eine Ende-zu-Ende-Verschlüsselung zwischen den
    Kommunikationsteilnehmern gewährleistet werden
    \end{enumerate}


    \newpage
    \section{Matrix}\label{sec:matrix}

    \subsection{Matrix Protokoll}\label{subsec:matrix-protokoll}
    Das Matrix Protokoll ist ein offener Standard für dezentrale Echtzeitkommunikation im Internet.
    Es ist ein Open-Source-Projekt welches unter Aufsicht der Matrix.org Foundation, einer Non-Profit-Organisation aus England, entwickelt wird.
    Das Team besteht aus 12 Personen, viele von ihnen mit weitreichenden Erfahrungen im Bereich VoIP- und Messaging-Apps für Mobilgeräte.
    Die Entwicklung begann im Jahr 2014 und ist seit Juni 2019 für den Einsatz im Produktionsbetrieb geeignet.
    Mittlerweile gibt es zahlreiche Beiträge aus der Community, wodurch das Projekt weiter vorangetrieben wird.
    ~\cite{matrixfaq}

    Das ursprüngliche Ziel des Projektes war es ein Protokoll zu entwickeln, welches es Nutzern ermöglichen soll, anderen Nutzern Nachrichten zu schreiben oder diese anzurufen, unabhängig davon welche Platform diese benutzen.
    Langfristig soll Matrix ein generisches System zur Messaging und Datensynchronisation über HTTP für das ganze Internet bilden.
    ~\cite{matrixfaq}

    Hierzu definiert Matrix eine Reihe von REST-APIs:
    \begin{description}[leftmargin=!,labelwidth=5.5cm]
        \item [Client-Server-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/client-server-api/} zur Kommunikation zwischen Matrix kompatiblen Clients und einem Homeserver
        \item [Server-Server-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/server-server-api/} zum Nachrichtenaustausch und Synchronisation zwischen mehreren Homservern
        \item [Application-Service-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/application-service-api/} zur Erweiterung der Funktionalität von Matrix und Integration anderer Systeme
        \item [Identity-Service-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/identity-service-api/} beschreibt das Mapping zwischen Drittanbietern
        \item [Push-Gateway-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/push-gateway-api/} zum versenden von Push Notifications an Clients falls neue Events beim Homeserver eintreffen
    \end{description}



    \subsection{Funktionsweise}\label{subsec:funktionsweise}
    Matrix arbeitet wie ein dezentraler Konversationsspeicher.
    Hierbei werden Nachrichten (Events) zwischen den Homservern aller Teilnehmer eines Raumes synchronisiert.
    Somit hält jeder Homeserver eine Kopie des vollständigen Konversationsverlaufs.
    Selbst wenn ein Server zwischenzeitlich ausfällt können die anderen Teilnehmer ihre Konversation fortführen.
    Sollte der ausgefallene Server wieder aktiv werden kann er die verpassten Nachrichten nachtragen~\cite{matrix}.
    Alle Nachrichten einer Konversation werden in einem Directed Acyclic Graph (DAG) gespeichert.
    Dieser wird im Kontext von Matrix als Event-Graph bezeichnet.
    Hierbei besitzt jedes Event einen oder mehrere Eltern (außer der Wurzelknoten).
    Der Elternknoten eines sendeten Events ist das zuletzt versendete Event eines Raumes.
    Somit lässt sich der Event-Graph chronologisch ordnen.
    Hierzu wird jedem event ein Wert \texttt{depth} zugewiesen, welcher die Reihenfolge der Events beschreibt~\cite{eventgraph}.
    Im folgenden Beispiel ist ein Ablauf einer Konversation erklärt:\\

    \#Todo

%\usetikz
%\begin{figure}
%    \centering
%    \input{source/diagrams/matrix.tikz}
%    \caption{Beispielsituation}
%    \label{fig:matrixfunktionsweise}
%\end{figure}

    \newpage
    \subsection{Events}\label{sec:events}
    Jeglicher Datenaustausch im Matrix Protokoll wird als Event bezeichnet.
    Dies können das Senden einer Nachricht oder Aktualisieren eines Profilbildes sein.
    Jedes Event hat hierfür einen \texttt{type} definiert welcher die Art des Events beschreibt.
    Für jeden Typ kann ein Event unterschiedliche Daten enthalten.
    Es ist außerdem möglich, eigene Eventtypen zu erstellen~\cite{events}.\\
    Events können in 2 Kategorien~\cite{roomevents} unterteilt werden:
    \begin{description}[leftmargin=!,labelwidth=3.5cm]
        \item [State events] geben Auskunft über Zustandsänderungen in einem Raum. Dies können beispielsweise das Ändern des Raumnamens oder das Beitreten eines Nuzters zu einem Raum sein.
        \item [Message events] beschreiben die tatsächliche Kommunikation in einem Raum. Dies können das Senden einer Nachricht oder das Starten eines VoIP-Anrufes sein.
    \end{description}

    Jedes Event enthält mindestens folgende Attribute~\cite{eventformat}:
    \begin{description}[leftmargin=!,labelwidth=3.5cm]
        \item [content] der tatsächliche Inhalt der Nachricht. Dieser variiert abhängig vom Eventyp.
        \item [event\_id] ein eindeutiger Identifier für das jeweilige Event.
        \item [origin\_server\_ts] Zeitstempel beim Senden des Events.
        \item [room\_id] ein eindeutiger Identifier über welchen ein Event einem bestimmten Raum zugeordnet werden kann.
        \item [sender] die Matrix ID des Absenders des Events.
        \item [type] der Typ des Events.
    \end{description}

    Events werden meist in Kontext eines Raumes versendet.

    \newpage
    \subsection{Rooms}\label{subsec:rooms}
    Räume ermöglicht es Nutzern Events zu versenden und zu empfangen.
    Ein Raum ist hierbei theoretisches Konstrukt und wird lediglich über seine ID identifiziert.
    Diese hat das folgende Format:
    \begin{lstlisting}[language=bash,label={lst:roomid}]
        !opaque_id:domain
    \end{lstlisting}
    Beim versenden eines Events wird diese Raum ID angegeben.
    Somit können später alle Events aus dem Event Graph einem Raum zugeordnet werden.
    Der aktuelle Zustand eines Raumes ergibt sich aus allen an diesen Raum gesendeten Events (state Events)~\cite{rooms}.
    Außerdem wird für jeden Member eines Raumes ein Eintrag auf dem Homeserver angelegt, wodurch bestimmt wird welche Events von welchen Nutzer gelesen werden dürfen.
    Es gibt zusätzlich die Möglichkeit einen oder mehrere "Room Aliases" anzulegen welche dem Menschen das identifizieren eines Raumes vereinfachen.
    Diese sind im Format~\cite{rooms}:
    \begin{lstlisting}[language=bash,label={lst:roomalias}]
        #room_alias:domain
    \end{lstlisting}



    \subsection{Devices}
    Ein Device im Matrix Protokoll beschreibt weniger ein reales Gerät wie ein Computer oder Smartphone sondern viel mehr eine Instanz eines Matrixclients auf einem Gerät.
    So können beispielsweise mehrere Anwendungen auf einem Gerät installiert sein und jedes wäre sein eigenes Device.
    Jedes Device bekommt seine eigene \texttt{device\_id} zugewiesen.
    Dabei ist zu beachten, dass falls sich ein User von einer Anwendung abmeldet und sich auf dem selben Gerät bei der selben Anwendung erneut anmeldet nicht die gleiche \texttt{device\_id} zugewiesen bekommt.
    Je nach Client wird somit unterschiedlich häufig die \texttt{device\_id} gewechselt.
    In Webanwendungen wird bei jedem Anmelden ein neue \texttt{device\_id} angelegt, wohingegen bei Client auf Mobilgeräten oder Computern die gleiche \texttt{device\_id} wiederverwendet werden kann.
    Devices finden hauptsächlich Anwendung im Bereich der End-to-End Verschlüsselung.

    \newpage
    \subsection{End-to-End-Encryption}\label{subsec:verwendete-schlussel}
    Zur Verschlüsselung von Nachrichten werden der Olm und der Megolm Algorithmus verwendet.\\
    Der Olm Algorithmus ist ein Double-Ratchet-Algorithmus.
    Er wird dafür genutzt verschlüsselte Nachrichten zwischen 2 Parteien auszutauschen, wobei mit jeder Nachricht ein neuer Key zur Verschlüsselung abgeleitet wird.
    Dies geschieht durch verkettung einer Key Derivation Function (KDF).
    Hierbei werden 3 Ketten geführt, die root chain, sending chain und receiving chain.
    Die sending chain einer Partei gleicht der receiving chain der anderen Partei und andersrum~\cite{perrin2016double}.
    Für die Erstellung des Wurzelknotens werden 4 Keys benötigt.
    Man benötigt die Identity Keys beider Teilnehmer ($I_A$ und $I_B$) und jeweils einen Curve25519 one-time key ($E_A$ und $E_B$).
    Mithilfe des Diffie-Hellman-Verfahrens wird ein gemeinsamer geheimer Schlüssel S erzeugt.
    Zur Berechnung dieses Schlüssels wird die Elliptic Curve Diffie-Hellman (ECDH) angewendet.
    \begin{displaymath}
        S = ECDH(I_A,E_B)\parallel ECDH(E_A,I_B) \parallel ECDH(E_A,E_B)
    \end{displaymath}
    Aus diesem geheimen Schlüssel lassen sich dann mittels HKDF-SHA-256 der Chain-Key $C_{0,0}$ und der Root Key $R_0$ ableiten.
    \begin{displaymath}
        R_0 \parallel C_{0,0} = HKDF(0,S,"OLM\_ROOT",64)
    \end{displaymath}
    Mit diesen Keys können anschließend alle fortlaufenden Keys berechnet werden~\cite{olm}.
    Der berechnete Schlüssel der root chain wird als input der KDF für die sending bzw. receiving chain genutzt.
    Der hierbei entstehende Schlüssel wird zum Verschlüsseln der eigentlichen Nachricht genutzt.
    Somit erfüllt der Olm Algorithmus folgende Eigenschaften:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [Resilience]
        \item [Forward security] Vergangene Nachrichten sind geschützt wenn zu einem Zeitpunkt ein KDF Key bekannt wird.
        \item [Break-in recovery] Zukünftige Nachrichten sind geschützt wenn zu einem Zeitpunkt ein KDF Key bekannt wird.
    \end{description}

    Der Megolm Algorithmus wird zur Verschlüsslung von Gruppen-Chats verwendet.
    Es ist ein auf dem Advanced Encryption Standard (AES) basierender Ratchet-Algorithmus~\cite{megolm}.

    Zusammengefasst werden folgende Schlüssel für die End-to-End-Verschlüsselung im Matrix Protokoll benötigt:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [Ed25519 fingerprint key pair] wird benutzt um ein Gerät zu identifizieren. Jedes Device besitzt seinen eigenen Ed25519 Schlüssel.
        \item [Curve25519 identity key pair] wird genutzt um den gemeinsamen geheimen Schlüssel zu erstellen.
        \item [Curve25519 one-time keys] ein Set von einmal verwendbarer Keys um Aufbau einer Olm Sitzung.
        \item [Megolm encryption keys] wird benutzt um Nachrichten in Gruppen-Chats zu verschlüsseln.
        \item [Ed25519 Megolm signing key pair] Schlüssel zum Signieren von Nachrichten in Gruppen-Chats, dient der Authentifizierung des Absenders.
    \end{description}
    ~\cite{matrix-end-to-end-encryption}\\

    \#Todo



    \section{REST-API}\label{sec:rest}

    \#Todo

    \cite{dazer2012restful}

    \section{MVVM-Architektur}\label{sec:mvvm-architektur}
    Im allgemeinen dienen Anwendungsarchitekturen (Design Pattern) als Muster um wiederkehrende Entwurfsprobleme zu lösen, indem man auf bewährte Praktiken zurückgreift.
    Sie beschreiben die allgemeine Struktur der Anwendung und geben somit auch die Aufteilung des Quellcodes vor.
    Die richtige Wahl der Anwendungsarchitektur kann einen entscheidenden Einfluss darauf nehmen wie effizient die Entwicklung des Projektes verläuft.\\
    Das Ziel der \textbf{M}odel-\textbf{V}iew-\textbf{V}iew\textbf{M}odel Architektur ist es, Ausführungslogik und Benutzeroberfläche von einander zu trennen.
    Hierzu wird die Anwendung in 3 Bereiche unterteilt, welche in Abbildung~\ref{fig:mvvm}~\cite{Sun2017/01} zu sehen sind:\\
    \begin{figure}[h]
        \centering
        \input{source/diagrams/mvvm.tikz}
        \caption{Interaktionen im Model-View-ViewModel}
        \label{fig:mvvm}
    \end{figure}\\
    Dabei übernimmt jeder Teil eine bestimmte Funktion~\cite{Mishra2017}:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [View] Bildet die grafische Oberfläche der Anwendung. Sie nimmt Usereingaben entgegen und kommuniziert mit dem dem ViewModel.
        \item [Model] Repräsentiert und speichert die Daten der Anwendung. Es kommuniziert mit dem ViewModel.
        \item [ViewModel] Enthält die Ausführungslogik der Anwendung. Es kommuniziert Sowohl mit der View als auch dem Model. Außerdem ist es zuständig für die Kommunikation mit externen Systemen.
    \end{description}
    Die Verwendung der MVVM-Architektur bringt eine Reihe von Vorteilen~\cite{Anderson2012,Mishra2017} mitsich:
    \begin{enumerate}[label={(\arabic*)}]
        \item Es erlaubt eine unabhängige Entwicklung von Userinterface und Ausführungslogik.
        \item Views können während des Entwurfs mit Testdaten befüllt werden, um somit eine Vorschau der Ansicht zu erstellen.
        \item Es erlaubt die Nutzung mehrerer Views auf dem selben ViewModel.
        \item Es verteilt Code auf mehrere kleinerer Klassen an Stelle eines großen View-Controllers.
        \item Erlaubt den ein Satz von Unit Tests auch zu einem späteren Zeitpunkt ohne größere Veränderungen im Code.
    \end{enumerate}

    \chapter{Verwendete Technologien}\label{ch:verwendete-technologien}
    In diesem Kapitel werden die für die Implementierung der Plattform verwendeten Technologien vorgestellt.
    Es wird auf deren Funktionsweise eingegangen und ihre Verwendung in der Entwicklung der Plattform erklärt.


    \section{XCode}\label{sec:xcode}
    XCode\footnote{https://developer.apple.com/xcode/} ist eine von Apple bereitgestellte Entwicklungsumgebung für die Entwicklung von Anwendungen für Apple Betriebssysteme, darunter iOS.
    Sie ist für die Programmierung in Swift und Objective-C vorgesehen~\cite{xcode}.
    Sie stellt eine Reihe von Templates zur Verfügung die bei der Erstellung des Projektes helfen können.
    Für die Entwicklung der Plattform wurde die aktuelle Version XCode 14 verwendet.
    Diese kann aus dem Appstore heruntergeladen werden.

    \section{Simulator}\label{sec:simulator}
    Der Simulator wird zusammen mit XCode installiert und ermöglicht das Simulieren und Testen der entwickelten App.
    Er ist direkt in XCode integriert und erlaubt es das Programm über den debugger zu analysieren.
    Darüber hinaus sendet er log-Messages zurück an XCode welche ebenfalls zum Überwachen der Anwendung genutzt werden können.


    \section{Swift}\label{sec:swift}
    Swift\footnote{https://developer.apple.com/swift/}\\
    \#Todo

    \cite{Goodwill2015}

    \section{SwiftUI}
    SwiftUI\footnote{https://developer.apple.com/xcode/swiftui/} ist ein GUI-Toolkit zur\\

    \#Todo
    \cite{Cahill2021}
    \cite{Varma2019}


    \newpage
    \section{Cocoapods}\label{sec:cocoapods}
    CocoaPods\footnote{https://github.com/CocoaPods/CocoaPods} ist ein Dependency Manager für Objective-C und Swift Projekte.
    Es ermöglicht dem Entwickler Quellcode von verschiedenen Orten in ein Projekt einzubinden.
    Hierzu können über 92.000 Libraries verwendet werden.
    Besonders im Bereich von Mac OSX und iOS Development findet das Tool häufig Verwendung.
    CocoaPods unterstützt sowohl private als auch öffentliche Repositories über git, svn, brz, http und hg.
    Hierbei ist zu beachten, dass das nicht jedes Repository automatisch über Cocoapods eingebunden werden kann.
    Es muss zuerst ein Pod aus der jeweiligen Library erstellt werden.
    Das seit 2014 entwickelte Projekt ist Open Source und wurde seit dem von über 300 Entwicklern stetig verbessert.
    Es ist ein Kommandozeilen-Tool welches in Ruby implementiert wird.
    Somit kann es über den RubyGems Paketmanager heruntergeladen werden.
    Hierzu kann nach erfolgreicher Installation von Ruby folgendes Kommando in der Konsole ausgeführt werden:
    \begin{lstlisting}[language=bash,label={lst:cocoapods}]
        $ sudo gem install cocoapods
    \end{lstlisting}
    Mittels CocoaPods lassen sich dann alle benötigten Libraries im sogenannten Podfile definieren und importieren.
    Das Podfile ist eine einfache Textdatei in welcher die Zielplattform und eine Liste aller benötigter Libraries und ihrer jeweiligen Versionen angegeben wird.
    In Listing\ref{lst:podfile} ist die Struktur eins solchen Podfiles zu sehen.
    ~\cite{cocoapods1, cocoapods2, cocoapods3}
    \begin{lstlisting}[language={},firstnumber=1,label={lst:podfile},caption={Beispielstuktur eines Podfiles},captionpos=t]
platform :ios, '8.0'
use_frameworks!

target 'MyApp' do
  pod 'AFNetworking', '~> 2.6'
  pod 'ORStackView', '~> 3.0'
  pod 'SwiftyJSON', '~> 2.3'
end
    \end{lstlisting}


    \section{Matrix iOS SDK}\label{sec:matrix-sdk}
    Die Matrix iOS SDK \footnote{https://github.com/matrix-org/matrix-ios-sdk} ist eine Open Source Library welche zur für die Entwicklung Matrix basierter Anwendungen für iOS Geräte gedacht ist.
    Sie fungiert als Schnittstelle zwischen Client Application und Matrix Server.
    Hierzu werden die in der Client-Server-API definierten Operationen bereitgestellt.
    Um die Matrix SDK in ein Projekt einzubinden muss hierfür ein Eintrag im in Abschnitt~\ref{sec:cocoapods} erläuterten Podfile angelegt und installiert werden.
    ~\cite{matrixiossdk}
    \begin{lstlisting}[language={},label={lst:matrtix-sdk}]
        pod 'SwiftMatrixSDK'
    \end{lstlisting}
    Anschließend kann die Library im Swift Code importiert werden.
    \begin{lstlisting}[language=swift,label={lst:matrtix-sdk-swift}]
        import MatrixSDK
    \end{lstlisting}

    \section{Synapse}\label{sec:synapse}
    Synapse\footnote{https://github.com/matrix-org/synapse/} ist eine von der Matrix.org Foundation bereitgestellte Open Source Implementation eines Homeservers.
    Sie folgt den im Matrix Protokoll festgelegten REST-APIs.
    Die Entwicklung begann 2014 und kann seit 2019 im Produktivbetrieb genutzt werden~\cite{synapse}.
    Der Homeserver ist in Python geschrieben und kann somit auf jedem python fähigen Host betrieben werden, es wird jedoch empfohlen einen von Matrix.org bereitgestellten Dockercontainer zu verenden.

    \section{Docker}\label{sec:docker}
    Docker ist eine Containervirtualisierungssoftware welche es ermöglicht Anwendung vom Rest des Systems zu isolieren.
    Auch wenn sie nach außen wie eine virtuelle Maschine wirkt, bietet sie entscheidende Vorteile.
    Herkömmliche virtuelle Maschinen bilden eine vollständige Kopie eines Betriebssystems welches mittels einer Virtualisierungssoftware wie beispielsweise Oracle VirtualBox oder KVM auf einem Hypervisor betrieben werden muss.
    Betrachtet man den vollständigen Stack einmal von unten hat man zuallererst die Hardware des Hypervisors, auf diesem läuft ein Betriebssystem, worauf wiederum die Virtualisierungssoftware läuft, mit welcher eine isolierte Kopie eines anderen Betriebssystems erzeugt wird in welcher die eigentliche Anwendung dann läuft.
    Dies sorgt für erhebliche Einbußen in der Performance.
    Docker Container sind in der Lage in wenigen Sekunden zu starten.
    Sie laufen direkt auf dem Betriebssystem des Hypervisors sind aber dennoch isoliert vom Rest des Systems.
    Dies geschieht mithilfe zweier Linux Kernel Technologien, namespaces und cgroups~\cite{docker}.
    Docker arbeitet mit Container und Images wobei ein Image eine Reihe von Befehlen darstellt um eine gewünschte Umgebung zu erschaffen.
    Ein Container ist eine laufende Instanz eines Images.


    \chapter{Konzept}\label{ch:konzept}
    In diesem Kapitel werden 2 verwandte Projekte vorgestellt, welche die Entwicklung der Plattform beeinflusst haben.
    Nach der

    \section{Ähnlicher Projekte}\label{sec:analyse-ahnlicher-projekte}

    \subsection{TI-Messenger}\label{subsec:ti-messenger}
    Der TI-Messenger ist ein Projekt der Gematik GmbH.
    Es dient der Entwicklung eines Messaging-Standards für das deutsche Gesundheitswesen.
    Hierbei ist zu beachten, dass der TI-Messenger keine spezifische Anwendung beschreibt sondern vielmehr die Vernetzung einzelner Anbieter- und Sektorübergreifender Plattformen gewährleistet.
    Da jeder Bereich des Gesundheitswesens andere Ansprüche an einen Messenger hat muss eine freie Wahl der Plattform möglich sein, wobei jedoch eine Plattformübergreifende Kommunikation möglich sein muss.
    Die Gematik GmbH hat bereits die Spezifikationen zur Version 1.0.0 und 1.1.0 des TI-Messengers~\cite{timessenger3} veröffentlicht.
    Für diese Arbeit von besonderer Relevanz sind die Kapitel 4.1 \("\)Datenschutz und Sicherheit\("\) der jeweiligen Dokumente.
    Die erste Version des TI-Messengers soll zum Sommer 2023 in Betrieb gehen und sowohl Textnachrichten als auch Bild- und Tonübertragungen unterstützen~\cite{timessenger,timessenger2}.

    \subsection{Nio}
    Nio\footnote{https://github.com/niochat/nio} ist ein vom User kiliankoe gestartetes Projekt.
    Es ist ein Open Source Projekt und läuft unter der Mozilla Public License 2.0.
    Das im Februar 2020 gestartete Projekt wurde seither von einer Vielzahl anderer User weiterentwickelt.
    Der Nio Client ist ein in Swift geschriebener Messenger zur Nutzung im Matrix Netzwerk.
    Er befindet sich aktuell in noch in einer Beta-Phase.
    Das Anmelden, Erstellen von Räumen und Versenden von Nachrichten ist bereits möglich.
    Es können sowohl Textnachrichten als auch Fotos versendet werden.
    Darüber hinaus kann auf Nachrichten mittels Emojis reagiert werden.
    Es werden direkte Chats und Räume mit mehreren Personen unterstützt.
    Das Erstellen von Accounts über den Nio Client ist zum Zeitpunkt der Analyse noch nicht möglich.
    Ebenfalls wird auch keine End-2-End Verschlüsselung unterstützt.
    Darüber hinaus unterstützt der Nio Client eine Vielzahl von Sprachen.

    \newpage
    \section{Anforderungen}\label{sec:anforderungen}
    Basierend auf den Erkenntnissen der Analyse des Nio Clients und der in der Spezifikation des TI-Messengers festgelegten Anforderungen wurde eine Liste von Anforderungen erstellt, welche von der zu implementierenden Plattform unterstützt werden sollen.
    Hierbei wurde sich auf die Grundfunktionalität einer Messaging-App und auf den Datenschutz gerechten Umgang mit Daten fokussiert.
    Diese Anforderungen wurden nach der MoSCoW-Methode, einer Methodik die häufig Anwendung im Bereich des Projektmanagement findet, priorisiert.\\
    \textbf{Must}:
    \begin{enumerate}[label={\roman*.}, leftmargin=2.5cm]
        \item Der User muss über die App einen Account auf der Plattform anlegen können.
        \item Der User muss sich mit seinem Account in der App einloggen können.
        \item Der User muss sein Passwort ändern können.
        \item Dem User muss alle von beigetretenen Räume sehen können.
        \item Dem User muss neue Räume erstellen können.
        \item Der User muss zu neuen Räumen eingeladen werden können.
        \item Der User muss alle Nachrichten die in einem Raum gesendet wurden einsehen können.
        \item Nachrichten Inhalte müssen verschlüsselt, separat vom allgemeinen Speicherbereich des Endgeräts abgelegt werden.
        \item Der User muss Nachrichten in einem Raum senden können.
        \item Nachrichten zwischen Usern müssen End-to-End Verschlüsselt sein.
        \item Der Usern muss Nachrichten löschen können.
        \item Der User muss einen Raum verlassen können.
        \item Der User muss seinen Account deaktivieren können.
        \item Die App darf keinen Zugriff auf das Adressbuch des Endgerätes haben.
    \end{enumerate}


    \textbf{Should}:
    \begin{enumerate}[label={\roman*.}, leftmargin=2.5cm]
        \item Beim erstellen des Accounts soll eine zusätzliche Authentifizierungsmethode verwendet werden um Wahloses erstellen zon Accounts zu verhindern.
        \item Der User soll sich nur einmal einloggen müssen.
        \item Der User soll sich ausloggen können.
        \item Der Benutzer soll die Möglichkeit haben sein Profilbild und seinen Anzeigenamen anzupassen.
        \item Der vollständige Chat-Verlauf soll nur bei Bedarf geladen werden.
        \item Die App soll neben Textnachrichten auch andere Nachrichtentypen wie Fotos, Videos oder Audiodateien unterstützen.
        \item Die App soll den User über den Erhalt einer neuen Nachricht informieren.
        \item Die Übersicht der beigetretenen Räume soll nach letzter Aktivität sortiert werden.
    \end{enumerate}


    \textbf{Could}:
    \begin{enumerate}[label={\roman*.}, leftmargin=2.5cm]
        \item Die Liste der beigetretenen Räume kann gefiltert werden.
        \item Dem Erstellen eines Raumes kann dem User eine Liste von Usern vorgeschlagen werden, welche dem gesuchten Namen entsprechen.
        \item Dem User kann ein Typing-Indikator gezeigt werden.
        \item Die App kann auch mit anderen Homeservern verbunden werden.
        \item Der User kann den Inhalt einer Textnachricht in die Zwischenablage kopieren.
        \item Der User kann eine Nachricht weiterleiten.
        \item Der User kann Dateien welche in einem Raum verschickt wurden herunterladen.
        \item Die App kann im Landscape mode genutzt werden.
    \end{enumerate}

    \textbf{Won't}:
    \begin{enumerate}[label={\roman*.}, leftmargin=2.5cm]
        \item Die App wird Räume und Chat-Verläufe nicht local speichern und offline wiedergeben können.
        \item Die App wird keine Nachrichten entschlüsseln können, die mit einem anderen Gerät versendet wurden.
        \item Die App wird keine weiteren Sprachen unterstützen.
    \end{enumerate}

    \newpage
    \chapter{Implementierung}\label{ch:implementierung}
    Dieses Kapitel beschreibt die Vorgehensweise bei der Implementierung der Plattform und die Funktionsweise der einzelnen Elemente.
    Die Plattform selbst besteht aus 2 Teilen, einer App die auf den Endgeräten der Nutzer installiert wird und einem Server welcher die Kommunikation der Apps untereinander ermöglicht.


    \section{App}\label{sec:app}
    Die App wurde mittels XCode implementiert und über den Simulator getestet.
    Sie wurde in Swift in Kombination mit SwiftUI geschrieben.
    Um die Sicherheit u erhöhen wurde die App für die aktuelle Version iOS 16 entwickelt.
    Bei der Entwicklung der App wurde in 2 Etappen vorgegangen.
    Zuerst wurden basierend auf den in Abschnitt~\ref{sec:anforderungen} definierten Anforderungen mittels SwiftUI die benötigten Views erstellt.
    Hierbei musste darauf geachtet werden, dass die Elemente im Userinterface in ihrer Größe und Anordnung dynamisch blieben um sowohl auf kleineren Geräten wie dem iPhone 13 mini aber auch auf größeren Geräten wie dem Iphone 14 Pro Max bedienbar zu sein.
    Anschließend wurden die zugehörigen ViewModel angelegt und mit dem Elementen aus den Views verknüpft.
    Eine besondere Herausforderung hierbei war es dafür zu sorgen, dass sich die grafischen Elemente bei eintreffen neuer Events ordnungsgemäß aktualisieren.
    Für die Funktionalität der App wurden mittels Matrix SDK erzeugt.
    Da es für die SDK aktuell noch keine Dokumentation gibt wurde die von Matrix bereitgestellte Client-Server-API als Grundlage genommen und entsprechende Module und Funktionen in der SDK gesucht.
    Der Code selbst folgt der MVVM Architektur da sich diese durch die Verwendung von SwiftUI anbietet.
    Im Sinne der Internationalität wurde fur die Benutzeroberfläche die Sprache Englisch verwendet.

    \newpage
    \subsection{Login und Account Erstellung}\label{subsec:login-und-account-erstellung}

    Wenn die App das erste Mal gestartet wird gelangt man zuerst in die in Abbildung~\ref{fig:selecthomeserverview} zu sehende \texttt{SelectHomeserverView}.
    Diese View dient dazu sich mit dem Homeserver verbinden zu können.
    Sie spielt eine besondere Rolle während der Entwicklung da häufiger zwischen Entwicklungs- und Produktivumgebung gewechselt wurde.
    Der User hat die Möglichkeit den Homeserver mit welcher er sich verbinden möchte über den DNS-Adresse oder IP-Adresse zu erreichen.
    Des Weiteren kann der den Port des Homeservers angeben.
    Der default Port über den sich ein Client mit dem für Matrix Server verbindet ist 448 (und 8448 für die Kommunikation zwischen Servern untereinander).
    Für den Einsatz im Produktivbetrieb könnte diese View entfernt werden und die Adresse des Homeservers fest in der App festgelegt werden.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{homeserver_white}
        \centering
        \caption{SelectHomeserverView}\label{fig:selecthomeserverview}
    \end{figure}
%    \begin{wrapfigure}{R}{0.5\textwidth}
%        \begin{center}
%            \includegraphics[scale=0.5]{selecthomeserver}
%        \end{center}
%        \caption{SelectHomeserverView}\label{fig:selecthomeserverview}
%    \end{wrapfigure}
    Hat der User einen Homeserver eingetragen und klick auf connect prüft die App zuerst ob der Homeserver erreichbar ist.
    Hierzu wird eine Abfrage der Versionsnummer an den angegebenen Homeserver gesendet.
    Dies geschieht durch senden einer GET Anfrage an \texttt{/\_matrix/client/versions} (siehe Abschnitt~\ref{sec:rest}).
    Ist diese Anfrage erfolgreich wird der Homeserver im Model hinterlegt und der User gelangt zur \texttt{LoginView} welche in Abbildung ~\ref{fig:loginview} zu sehen ist.
    Falls die Anfrage fehlschlägt wird dem User eine Fehlermeldung gezeigt.
    \begin{figure}[h]
        \includegraphics[scale=0.5]{login_white}
        \centering
        \caption{LoginView}\label{fig:loginview}
    \end{figure}
    In dieser View kann der User sich entweder mit seinem bereits existierenden Account anmelden oder einen neuen Account erstellen.
    Für den Fall, dass der User bereits einen Account besitzt muss er seinen User namen und sein Passwort in die dafür vorgesehenen Felder eintragen und über den Login Button bestätigen.
    Das Passwortfeld ist hierbei ein \texttt{SecureField} welches die Eingabe versteckt und lediglich mit Punkten darstellt.
    Über das Auge am Rand des Textfeldes kann der User zwischen geschützter Ansicht und Klartext wechseln.


    Hat der User seine Zugangsdaten eingegeben und über den Login Button bestätigt wird über den \texttt{MXRestClient}, welcher von der SDK (siehe Abschnitt~\ref{sec:matrix-sdk}) bereit gestellt wird, eine Login-Anfrage mit Usernamen und Passwort an den Server gesendet.
    Bei gültigen zugangsdaten enthält die Antwort des Servers folgende Informationen:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [home\_server] die vollständige Adresse des Homeservers
        \item [access\_token] ein Access Token zur weiteren Verwendung mit dem \texttt{MXRestClient}
        \item [user\_id] die vollständige Matrix ID des Users
        \item [device\_id] die vom Server zugewiesene ID für das Gerät
    \end{description}
    Die Information über \texttt{home\_server}, \texttt{user\_id} und \texttt{device\_id} werden in den \texttt{UserDefaults} der App gespeichert.
    Da der \texttt{access\_token} den Zugriff auf Benutzerkonto des Users ermöglicht, wird dieser mittels eines \texttt{KeychainHelper}\footnote{https://gist.github.com/LeeKahSeng/2452e90a57a5324de367907a36d88a49} in der iCloud Keychain gespeichert.
    Falls die Zugangsdaten nicht korrekt sind wird dem User erneut eine Fehlermeldung gezeigt.
    Anschließend wird mit diesen Information eine Matrix Session gestartet welche vollen Zugriff auf die Nutzerdaten
    War das starten der Session erfolgreich gelangt der User in die \texttt{RoomsView}.\\

    Für Den Fall das der User noch keinen Account besitzt kann über den Button "Create Account" der \texttt{LoginView} zur \texttt{CreateAccountView} gelangen welche in Abbildung~\ref{fig:createaccountview} dargestellt ist.
    Diese View dient der Account erstellung und enthält 3 Textfelder für Benutzernamen, Passwort und Registrierungstoken.
    Für das Passwortfeld kann wie schon in der \texttt{LoginView} zwischen versteckter Eingabe und Klartet gewechselt werden.
    \begin{figure}[h]
        \includegraphics[scale=0.5]{accountcreate_white}
        \centering
        \caption{CreateAccountView}\label{fig:createaccountview}
    \end{figure}
    Der Registrierungstoken kann über die Admin-API\footnote{https://matrix-org.github.io/synapse/latest/usage/administration/admin\_api/} des Servers erstellt werden.
    Hierzu muss eine GET-Anfrage an \texttt{/\_synapse/admin/v1/registration\_tokens/new} gesendet werden.~\cite{synapseregistartiontoken}
    Alternativ kann auch direkt in der Datenbank des Servers ein Token angelegt werden (im \texttt{registration\_tokens} table).
    Es werden folgende Felder bereitgestellt:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [token] Der Token der bei der Erstellung des Accounts angegeben werden muss.
        \item [uses\_allowed] Die maximale Anzahl an Accounts die mit einem Token erstellt werden kann.
        \item [pending] Anzahl laufender Registrierungen.
        Sie gibt an wie viele Benutzer die Authentifizierungsstufe mit dem Token bereits abgeschlossen haben ohne den vollständigen Registrierungsvorgang erfüllt zu haben.
        \item [completed] Anzahl erfolgreich erstellter Accounts mit diesem Token.
        \item [expiry\_time] Ablaufdatum des Tokens. Er gibt an wie lange der Token gültig ist.
    \end{description}

    Der eigentliche Registrierungsvorgang kann mehrere Authentifizierungsstufen enthalten.
    Bevor der Registrierungsvorgang gestartet wird ir zuvor mit der vom \texttt{MXRestClient} bereitgestellten Funktion geprüft ob der Benutzername bereit genutzt wird.
    In dieser Implementation wird der in Abbildung~\ref{fig:accountCreationDiagram} beschriebene dreistufige Accounterstellungsvorgang mittels eines Registriersungstokes genutzt.

    \begin{figure}[h]
        \centering
        \begin{sequencediagram}
            \newthread{A}{Client}{}
            \newinst[7]{B}{Server}{}
            \begin{sdblock}{Stage 1}{Receive Session ID}
                \begin{call}{A}{getRegistrationSession()}{B}{\shortstack{
                    return Session ID\\
                    return supported flows}}
                    \postlevel
                \end{call}
            \end{sdblock}
            \begin{sdblock}{Stage 2}{m.login.registration\_token}
                \begin{call}{A}{register()}{B}{}
                \end{call}
            \end{sdblock}
            \begin{sdblock}{Stage 3}{m.login.dummy}
                \begin{call}{A}{register()}{B}{}
                \end{call}
            \end{sdblock}
        \end{sequencediagram}
        \caption{Account erzeugungs Flow}
        \label{fig:accountCreationDiagram}
    \end{figure}

    Im ersten Schritt sendet der Client eine leere Anfrage zum Server in welcher er um das starten einer Registrierungssitzung bittet.
    Der Server antwortet daraufhin mit einer SessionID und den vom Homeserver unterstützten Authentifizierungs-Flows.
    In diesem Beispiel ist der einzige unterstützte Flow die verifizierung über einen Registriersungstoken.
    Im nächsten Schritt sendet der Client dann den zuvor bereitgestellten Registrierungstoken und die vom Server gegebene SessionID in Kombination mit der aktuellen Stufe des Authentifizierungsvorgangs.
    Im dritten und letzten Schritt wird nun der dummyflow aufgeführt.
    Dieser Flow kann nicht fehlschlagen und dient der zur finalen Erstellung des Account.
    Hierbei werden der gewünschte Benutzername und Passort übergeben.
    Ist dies geschehen wurde der Account erfolgreich erstellt.
    Anschließend wird der User ebenfalls auf die \texttt{RoomsView} weitergeleitet.

    \newpage
    \subsection{Raumübersicht}\label{subsec:raumubersicht}

    Die \texttt{RoomsView} bildet das Herzstück der App.
    Sie ist die Ansicht die dem User bei jedem Start der App gezeigt wird sofern er sich bereits in der App angemeldet hat.
    Von dieser Ansicht aus können alle weiteren Views erreicht werden.
    Die in Abbildung~\ref{fig:roomsview} gezeigte View besteht aus einer \texttt{Toolbar} im Kopf der Ansicht über welche man zur \texttt{ProfileView} und \texttt{SettingsView} gelangt.
    Darunter findet sich die Raum übersicht welche alle beigetretenen Räume in einer scrollbaren Liste anzeigt.
    Jedes Element der Liste zeigt den das Profilbild des jeweiligen Raumes sowie Displayname oder Title des jeweiligen Raumes.
    Bei direkten Räumen wird außerdem die MatrixID des Users angezeigt, da User ihren Anzeigenamen beliebig ändern können.
    Auf das Zeigen einer Vorschau der letzten Nachricht wurde hierbei im Sinne des Datenschutzes bewusst verzichtet.
    Auf der rechten Seite befindet sich der Zeitpunkt der letzten Nachricht und ein Indikator dafür ob und wie viele ungelesene Nachrichten im einem Raum existieren
    Über das darüberliegende Textfeld kann kann die Liste gefiltert werden.
    Darüber hinaus wird die Liste nach dem  \texttt{originServerTimestamp} der letzten Nachricht des jeweiligen Raumes sortiert.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{rooms_white}
        \centering
        \caption{RoomsView}\label{fig:roomsview}
    \end{figure}
    Über den Button mit dem Plus gelangt man zur \texttt{NewRoomView} in welcher man einen neun Raum erstellen kann.
    Im Fuß der View befindet sich eine TabView über welche zwischen \texttt{RoomsView} und \texttt{InvitesView} gewechselt werden kann.
    Die \texttt{InvitesView} welche in Abbildung~\ref{fig:invitesview} zu sehen ist dient dazu alle offenen Einladungen zu anderen Räumen aufzulisten.
    Diesen kann durch einfaches klicken auf den jeweiligen Raum beigetreten werden.
    Man gelangt dann zur \texttt{ChatView} und kann direkt mit dem jeweiligen Raum Kommunizieren.
    Falls man die Einladung ablehnen möchte kann man dies durch wischen der Einladung in Richtung des linken Bildschirmrandes tun.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{invites_white}
        \centering
        \caption{InvitesView}\label{fig:invitesview}
    \end{figure}

    \newpage
    \subsection{Raumerzeugung}\label{subsec:raumerzeugung}
    Hat der User in der \texttt{RoomsView} oder \texttt{InvitesView} auf den Plus-Button geklickt gelangt er in die \texttt{NewRoomView}.
    Diese View dient dazu neue Räume zu erstellen und User zu diesen einzuladen.
    Hierzu wird dem User wie in Abbildung~\ref{fig:newroomview} zu sehen, ein Textfeld gezeigt über welches er nach anderen Usern über deren Anzeigenamen oder ihre MatrixID suchen kann.
    In der sich in der Unteren hälfte befindlichen scrollbaren Liste werden bis zu 10 Nutzer gezeigt die dem eingegebenen Suchtext entsprechen.
    Diese Funktion ist nur möglich falls in der Konfiguration des Homeservers die suche im Nutzerverzeichnis freigegeben ist.
    Die Konfiguration des Homeservers ist in Abschnitt~\ref{sec:homeserver} genauer beschrieben.
    Ist diese Funktion nicht freigegeben muss der User die vollständige MatrixID des gesuchten Nutzers angeben.
    Hat der User den von ihm gesuchen Nutzer gefunden kann er durch anklicken dem zu erstellenden Raum hinzufügen.
    Der Nutzer erscheint dann in der horizontal scrollbaren Liste von Usern.
    Hat der User einen falschen Nutzer zum Raum hinzugefügt kann er diesen durch antippen des Users in der Liste hinzugefügter Nutzer wieder entfernen.
    Hierbei achtet die App darauf, dass ein Nutzer nicht doppelt hinzugefügt werden kann.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{newroom_white}
        \centering
        \caption{NewRoomView}\label{fig:newroomview}
    \end{figure}

    Hat der User alle von ihm gewünschten Nutzer dem Raum hinzugefügt kann er diesen durch klicken auf den "Create"-Button erstellen.
    Die App entscheidet dann automatisch anhand der Anzahl der eingeladenen Usern ob ein direkter Raum erstellt werden soll oder nicht.
    Nach erstellen der Raumes wird automatisch ein StateEvent von Typ \texttt{.roomEncryption} an den Raum gesendet, welche die anderen Nutzer im Raum darüber informiert das Nachrichten in diesem Raum verschlüsselt zu senden sind.
    Der vollständige Vorgang zum verschlüsseln der Nachrichten ist in Abschnitt~\ref{subsec:verschlusselung-der-nachrichten} beschrieben.
    War das erstellen der Raumes erfolgreich wird der User in die \texttt{ChatView} des neu angelegten Raumes geleitet.

    \newpage
    \subsection{Chatfenster}
    Die in Abbildung~\ref{fig:chatview} gezeigte \texttt{ChatView} ist eine weitere Kernansicht der App.
    Sie ermöglicht es dem User Konversationen eines Raumes einzusehen und neue Nachrichten an diesen zu senden.
    Die Abbildung zeigt Beispielnachrichten für alle unterstützten Nachrichtentypen.
    Es können einfache Textnachrichten versendet werden, Fotos welche durch antippen in einem Fullscreen \texttt{ImageViewer} angezeigt werden,
    PDF-Dateien welche in einem \texttt{PDFViewer} eingesehen werden können, und Videos welche mittels \texttt{AZVideoPlayer} abgespielt werden können.
    Der Videoplayer unterstützt sowohl das abspielen direkt in der \texttt{ChatView} als auch im Fullscreenmode, sowohl im Landscape- als auch im Portrait-format.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{chat_white}
        \centering
        \caption{ChatView}\label{fig:chatview}
    \end{figure}

    Des weiteren wird dem User ein Typing-Indikator gezeigt welcher der User darüber informiert ob der Gesprächspartner (oder in Multiuser Räumen welche Gesprächspartner) gerade eine Nachricht schreiben.
    Im Fuß der Ansicht befindet sich das Nachrichtenfenster über welches Nachrichten verfasst und an der Raum gesendet werden können.
    Durch klicken des Bild-Icons öffnet sich ein \texttt{ImagePicker} über welchen sowohl Fotos als auch Videos aus der Galerie gewählt und an den Raum gesendet werden können.
    Das Kamera-Icon daneben öffnet eine Kamera Ansicht über welche Fotos und videos direkt aus der App aufgenommen und versendet werden können.
    Über das Büroklammer-Icon lassen sich Dateien die auf dem Gerät gespeichert sind durchsuchen und an den Raum senden.
    Da nur Dateien vom Typ PDF von der App unterstützt werden wird im Datei Picker ebenfalls nach PDF gefiltert.
    Im Kopf der Ansicht erkennt man eine Hinweismeldung darauf, dass man das Ende der geladenen Nachrichten erreicht hat und nach unten wischen muss um weitere Nachrichten zu laden.
    Bei öffnen der \texttt{ChatView} werden sofern vorhanden 25 Nachrichten geladen.
    Dies geschieht mittels pagination der Matrix Timeline eines Raumes.
    Bei jedem weiteren laden von Nachrichten werden 25 weitere Nachrichten geladen und angezeigt.
    Es muss darauf geachtet werden, dass die Reihenfolge der Nachrichten ordnungsgemäß angezeigt wird.
    Die Lazy-Loading-Methode erlaubt hierbei eine angemessene Performance beim öffnen des Chats.
    Eine besondere Herausforderung ist die Position der scrollbaren Liste.
    Beim öffnen der View muss an das Ende der Liste gesprungen werden, da sich dort die neusten Nachrichten befinden.
    Falls eine neue Nachricht eintrifft während die View geöffnet ist springt die Liste ebenfalls an das Ende um dem Nutzer die neuste Nachricht anzuzeigen.
    Beim Laden älterer Nachrichten soll jedoch nicht zum Ende gesprungen werden.
    Über die drei Punkte in der oberen rechten Ecke der Ansicht öffnet sich ein Drop-Down-Menu über welches ein Raum verlassen werden kann oder sich eine Übersicht über den aktuellen Raum öffnet, wo Titel, Beschreibung und Bild des Raumes geändert werden können.
    Darüber hinaus zeigt sie einige Informationen über den Raum an wie die Anzahl an Teilnehmern, den Ersteller des Raumes und ob die Verschlüsselung aktiv ist.

    \newpage
    \subsection{Profile}\label{subsec:profile}
    Die \texttt{ProfileView} welche in Abbildung~\ref{fig:profileview} zu sehen ist erlaubt dem user seinen Account zu verwalten.
    Durch klicken auf das Profilbild öffnet sich der \texttt{ImagePicker}, welcher auch schon in der \texttt{ChatView} genutzt wurde, wodurch der Nutzer ein neues Profilbild setzen kann.
    Außerdem kann er seinen Anzeigenamen ändern.
    Die Matrix ID bleibt hierbei jedoch gleich.
    Darüber hinaus wird dem User die Möglichkeit geboten sein Passwort zu ändern.
    Hierfür öffnet sich nach klicken des Buttons ein alert welcher den Nutzer um Eingabe seines alten und seines neuen Passworts bittet.
    Falls das alte Passwort korrekt eingegeben wurde wird das neue Passwort gesetzt.\\
    Im unteren Teil der Ansicht befinden sich 2 Buttons, ein logout und ein delete Button ..  .. . . .
    \#Todo

    \begin{figure}[h]
        \includegraphics[scale=0.5]{profile_white}
        \centering
        \caption{ProfileView}\label{fig:profileview}
    \end{figure}

    \begin{figure}[h]
        \centering
        \begin{sequencediagram}
            \newthread{A}{Client}{}
            \newinst[7]{B}{Server}{}
            \begin{sdblock}{Stage 1}{Receive Session ID}
                \begin{call}{A}{getLoginSession()}{B}{\shortstack{
                    return Session ID\\
                    return supported flows}}
                    \postlevel
                \end{call}
            \end{sdblock}
            \begin{sdblock}{Stage 2}{m.login.password}
                \begin{call}{A}{deactivateAccount()}{B}{}
                \end{call}
            \end{sdblock}
        \end{sequencediagram}
        \caption{Account löschen Flow}\label{fig:figure}
    \end{figure}

%    \subsection{Start der Matrix Session}\label{sec:start-der-matrix-session}

    \subsection{Verschlüsselung der Nachrichten}\label{subsec:verschlusselung-der-nachrichten}
    Zur Verschlüsselung der Nachrichten sind mehrere Schritte notending.
    Zuerset muss die Verschlüsselung in der Sitzung aktiviert werden.
    Dies geschieht durch starten und aktivieren des Crypto Modules der SDK.
    Dabei werden die im Abschnitt~\ref{subsec:verwendete-schlussel} aufgeführten Schlüssel erstellt und mit dem Server synchronisiert.
    Zusätzlich mus beim erstellen eines Raumes zuallererst ein encryption Event gesendet werden, welches die anderen Teilnehmer eines Raums darüber informiert, dass die Kommunikation in einem Raum verschlüsselt zu erfolgen hat.
    Hierbei muss der für die Verschlüssleung der Nachricht verwendete Algorithmus angegeben werden.
    Zur Zeit wird nur die \texttt{m.megolm.v1.aes-sha2} Verschlüsselung von der SDK unterstützt.
    Falls nun eine Nachricht über die Sitzung an den erstellten Raum gesendet wird, wird diese beim senden automatisch von der SDK verschlüsselt.
    Beim Empfangen von Nachrichten wird das Event ebenfalls automatisch entschlüsselt.
    Bei Fotos, Videos und Datein ist zu beachten, dass das Event lediglich einen Pfad zum Ablageort der gesendeten Datei auf dem Server enthält.
    Dieser Pfad muss nun übersetzt werden und anschließend heruntergeladen werden.
    Da die Dateien nach dem herunterladen noch immer verschlüsselt sind müssen diese anschließend mit der von der SDK bereitgestellten Funktion \texttt{MXEncryptedAttachments.decryptAttachment()} separat entschlüsselt werden.
    Anhand der Notwendigkeit des entschlüsselns der Dateien kann bestätigt werden, dass die Verschlüsslung aktiv ist.
    Zusätzlich kann auf dem Homeserver unter \texttt{/data/media\_store} geprüfte werden, dass die Dateien verschlüsselt auf dem Server abgelegt werden.

    \subsection{Benachrichtigungen}\label{subsec:benachrichtigungen}
    \#Todo

    \newpage
    \section{Homeserver}\label{sec:homeserver}
    Der Homeserver bildet die unterliegende Infrastruktur der Plattform.
    Hierfür wird das vom Matrix Team bereitgestellte Synapse Docker Image verwendet.
    Diese wird in einem Docker Container auf dem Server betrieben.
    Bevor der Container gestartet werden kann, werden einige Konfigurationsdateien benötigt welche über folgenden Befehl generiert werden können:
    \begin{lstlisting}[language=bash,label={lst:synapse-generate}]
docker run -it --rm -v /path/on/host/machine/:/data -e SYNAPSE_SERVER_NAME=my.matrix.host -e SYNAPSE_REPORT_STATS=yes matrixdotorg/synapse:latest generate
    \end{lstlisting}
    Um später einfacher Änderungen an der Konfiguration des Homeservers vornehmen zu können wird das \texttt{/data} Directory im Host gemounted.
    Des weiteren muss der Name des Homeservers über \texttt{SYNAPSE\_SERVER\_NAME} definiert werden.
    Dieser wird später für die Identifikation des Homeservers genutzt.
    Nach ausführen des Befehls werden 3 Dateien generiert:
    \begin{description}[leftmargin=!,labelwidth=4cm]
        \item [homeserver.yaml] Konfigurationsdatei des Homeservers. Hier können alle Funktionalitätet des Homeservers konfiguriert werden.
        \item [my.matrix.host.log.config] Konfigurationsdatei des Loggers. Hier kann das Fromat für Log-Messages definiert werden und weitere
        \item [my.matrix.host.signing.key] Key zur Authentifizierung bei anderen Homeservern
    \end{description}

    Der \texttt{my.matrix.host.signing.key} wird für diese Implementation nicht benötigt, da der einzeln läuft und nicht an das Matrix Netzwerk angeschlossen wird.
    Bevor der Server gestartet wird sollten noch einige Konfigurationen angepasst werden:
    \begin{enumerate}[label={(\arabic*)}]
        \item Standardmäßig wird nur ein Listener auf Port 8008 für ungeschützte Verbindungen über HTTP konfiguriert.
                Um die App mit dem Homeserver verbinden zu können muss ein zusätzlicher HTTPS Listener auf Port 443 konfiguriert werden.
            \begin{lstlisting}[language=yaml,label={lst:listener}]
listeners:
  - port: 443
    type: http
    tls: true
    resources:
          - names: [client]
            \end{lstlisting}
        \item Für den zusätzlichen Listener über HTTPS muss ein SSL Zertifikat erstellt werden und in der Konfiguration hinterlegt werden. Während der Entwicklung wurde hierfür ein selbst signiertes Zertifikat mittels Open SSL generiert.
            \begin{lstlisting}[language=yaml,label={lst:ssl-certificate}]
tls_certificate_path: "/data/certs/cert.pem"
tls_private_key_path: "data/certs/key.pem"
            \end{lstlisting}
        \item Da während der Entwicklung ein selbst signiertes Zertifikat verwendet wurde muss zusätzlich die Zertifikat Verifikation ausgeschaltet werden.
            \begin{lstlisting}[language=yaml,label={lst:disable-cert}]
federation_verify_certificates: false
            \end{lstlisting}
        \item Da der Server nicht mit dem Matrix Netzwerk verbunden wird muss die Key Verifizierung über den Matrix Root Server deaktiviert werden.
            \begin{lstlisting}[language=yaml,label={lst:disable-key-verification}]
trusted_key_servers:
  - server_name: "matrix.org"
    accept_keys_insecurely: true
            \end{lstlisting}
        \item Um das in Abschnitt~\ref{subsec:raumerzeugung} beschriebene durchsuchen des Nutzerverzeichnisses zu ermöglichen muss dies hier erlaubt werden.
            \begin{lstlisting}[language=yaml,label={lst:user-directory}]
user_directory:
  enabled: true
  search_all_users: true
            \end{lstlisting}
        \item Zusätzlich können Regeln aktiviert werden die beim Erstellen eines Account Prüfen ob das Passwort den gewünschten Richtlinien entspricht.
                Hier kann definiert werden welche Arten von Zeichen im Passwort enthalten sein müssen und wie lang das Passwort mindestens sein muss.
            \begin{lstlisting}[language=yaml,label={lst:password-policy}]
password_config:
   enabled: true
   localdb_enabled: true
   pepper: "EVEN_MORE_SECRET"

   policy:
      enabled: true
      minimum_length: 8
      require_digit: true
      require_symbol: true
      require_lowercase: true
      require_uppercase: true
            \end{lstlisting}
        \item Da die Registrierung nur mit einem Registrierungstoken möglich sein soll muss dies ebenfalls angegeben werden.
        \begin{lstlisting}[language=yaml,label={lst:enable-registration}]
enable_registration: true
registration_requires_token: true
        \end{lstlisting}
        \item Als weiter Absicherung, dass auch alle Räume verschlüsselt sind werden Raume standardmäßig verschlüsselt.
    \begin{lstlisting}[language=yaml,label={lst:enable-encryption}]
encryption_enabled_by_default_for_room_type: all
    \end{lstlisting}
    \end{enumerate}

    Nachdem alle Konfigurationen getätigt wurden kann der Homeserver gestartet werden.
    Es ist darauf zu achten, dass alle benötigten Ports des Containers über den Host freigegeben werden.

    \begin{lstlisting}[language=bash,label={lst:synapse-start}]
docker run -d --name synapse -v /path/on/host/machine/:/data -p 8008:8008 -p 443:443 matrixdotorg/synapse:latest
    \end{lstlisting}

    Nach dem Start des Containers ist der Homeserver einsatzbereit und Clients können eine Verbindung aufnehmen.
    Es wird außerdem eine Datenbank angelegt.
    Für die Implementation wird die standardmäßig konfigurierte SQLite Datenbank verwendet.
    Hier werden alle für den Betrieb des Homeservers benötigten Tabellen angelegt.
    Außerdem wird ein \texttt{media\_store} Ordner angelegt, welcher alle versendeten Dateien der Nutzer enthält.

    \newpage
    \chapter{Evaluation}\label{ch:evaluation}
    In diesem Kapitel werden die in Abschnitt~\ref{sec:anforderungen} definierten Anforderungen auf ihre Implementation geprüft.
    Hierbei werden die mit Won't priorisierten Anforderungen nicht beachtet.

    \newpage
    \section{Must-Anforderungen}\label{sec:must-anforderungen}
    \begin{table}[h]
        \centering
        \begin{tabular}{p{0.57\textwidth}|p{0.37\textwidth}}
            Anforderung & Status\\
            \cline{1-2}
            Der User muss über die App einen Account auf der Plattform anlegen können.
            &  \textbf{Erfüllt} \\
            \cline{1-2}
            Der User muss sich mit seinem Account in der App einloggen können. &  \textbf{Erfüllt} \\
            \cline{1-2}
            Der User muss sein Passwort ändern können. & \textbf{Erfüllt}  \\
            \cline{1-2}
            Dem User muss alle von beigetretenen Räume sehen können. &  \textbf{Erfüllt} \\
            \cline{1-2}
            Dem User muss neue Räume erstellen können. & \textbf{Erfüllt} \\
            \cline{1-2}
            Der User muss zu neuen Räumen eingeladen werden können. & \textbf{Erfüllt} \\
            \cline{1-2}
            Der User muss alle Nachrichten die in einem Raum gesendet wurden einsehen können. & \textbf{Erfüllt} \\
            \cline{1-2}
            Nachrichten Inhalte müssen verschlüsselt, separat vom allgemeinen Speicherbereich des Endgeräts abgelegt werden. & \textbf{Erfüllt} (keine lokale Speicherung implementiert) \\
            \cline{1-2}
            Der User muss Nachrichten in einem Raum senden können. & \textbf{Erfüllt} \\
            \cline{1-2}
            Nachrichten zwischen Usern müssen End-to-End Verschlüsselt sein. & \textbf{Erfüllt} \\
            \cline{1-2}
            Der Usern muss Nachrichten löschen können. & \textbf{Nicht erfüllt} \\
            \cline{1-2}
            Der User muss einen Raum verlassen können. & \textbf{Erfüllt} \\
            \cline{1-2}
            Der User muss seinen Account deaktivieren können. & \textbf{Erfüllt} (kein automatisches Löschen der Daten erfolgt)\\
            \cline{1-2}
            Die App darf keinen Zugriff auf das Adressbuch des Endgerätes haben. & \textbf{Erfüllt}
        \end{tabular}
        \caption{Übersicht über erfüllte Must-Anforderungen}
        \label{tab:erfüllte-must-anforderungen}
    \end{table}

    \newpage
    \section{Should-Anforderungen}\label{sec:should-anforderungen}
    \begin{table}[h]
        \centering
        \begin{tabular}{p{0.57\textwidth}|p{0.37\textwidth}}
            Anforderung & Status\\
            \cline{1-2}
            Beim erstellen des Accounts soll eine zusätzliche Authentifizierungsmethode verwendet werden um Wahloses erstellen zon Accounts zu verhindern.
            &  \textbf{Erfüllt} (mittels Registrierungstoken)\\
            \cline{1-2}
            Der User soll sich nur einmal einloggen müssen. &  \textbf{Erfüllt} \\
            \cline{1-2}
            Der User soll sich ausloggen können. & \textbf{Erfüllt}  \\
            \cline{1-2}
            Der Benutzer soll die Möglichkeit haben sein Profilbild und seinen Anzeigenamen anzupassen. &  \textbf{Erfüllt} \\
            \cline{1-2}
            Der vollständige Chat-Verlauf soll nur bei Bedarf geladen werden. & \textbf{Erfüllt} (Lazy-Loading)\\
            \cline{1-2}
            Die App soll neben Textnachrichten auch andere Nachrichtentypen wie Fotos, Videos oder Audiodateien unterstützen. & \textbf{Teilweise erfüllt} (unterstützt Foto, Video und PDF) \\
            \cline{1-2}
            Die App soll den User über den Erhalt einer neuen Nachricht informieren. & \textbf{Erfüllt} \\
            \cline{1-2}
            Der User muss Nachrichten in einem Raum senden können. & \textbf{Erfüllt} \\
            \cline{1-2}
            Die Übersicht der beigetretenen Räume soll nach letzter Aktivität sortiert werden. & \textbf{Erfüllt}
        \end{tabular}
        \caption{Übersicht über erfüllte Should-Anforderungen}
        \label{tab:erfüllte-should-anforderungen}
    \end{table}

    \newpage
    \section{Could-Anforderungen}\label{sec:could-anforderungen}
    \begin{table}[h]
        \centering
        \begin{tabular}{p{0.57\textwidth}|p{0.37\textwidth}}
            Anforderung & Status\\
            \cline{1-2}
            Die Liste der beigetretenen Räume kann gefiltert werden. &  \textbf{Erfüllt} \\
            \cline{1-2}
            Dem Erstellen eines Raumes kann dem User eine Liste von Usern vorgeschlagen werden, welche dem gesuchten Namen entsprechen. & \textbf{Erfüllt}  \\
            \cline{1-2}
            Dem User kann ein Typing-Indikator gezeigt werden. &  \textbf{Erfüllt} \\
            \cline{1-2}
            Die App kann auch mit anderen Homeservern verbunden werden. & \textbf{Teilweise erfüllt} (Accounterstellung nicht möglich)\\
            \cline{1-2}
            Der User kann den Inhalt einer Textnachricht in die Zwischenablage kopieren. & \textbf{Nicht erfüllt} \\
            \cline{1-2}
            Der User kann eine Nachricht weiterleiten. & \textbf{Nicht erfüllt}  \\
            \cline{1-2}
            Der User kann Dateien welche in einem Raum verschickt wurden herunterladen. & \textbf{Nicht erfüllt}  \\
            \cline{1-2}
            Die App kann im Landscape mode genutzt werden. & \textbf{Teilweise erfüllt}
        \end{tabular}
        \caption{Übersicht über erfüllte Could-Anforderungen}
        \label{tab:erfüllte-could-anforderungen}
    \end{table}


    \chapter{Fazit}\label{ch:fazit}
    Die Plattform erfüllt die grundlegenden Anforderungen welche man an eine Messanger-App hat.
    Sie bietet die Möglichkeit einen Account anzulegen, zu verwalten und wieder zu löschen.
    Sie erlaubt das Erstellen, Beitreten und Löschen von Räumen sowohl in Direkt- als auch in Gruppenräumen.
    Das Senden und Empfangen von Nachrichten geschieht in Echtzeit und mit End-to-End Verschlüsselung, sodass der Betreiber der Platform keinerlei Zugriff auf die Daten der Nutzer hat.
    Dabei unterstützt die Platform die gängigsten Nachrichtentypen und sorgt dafür, dass keine personenbezogenen Daten auf dem Gerät gespeichert sind.\\
    Betrachtet man jedoch die Anforderungen welche von der DSGVO an eine Messaging-App im medizinischen Bereich gestellt werden muss man feststellen, dass eine vielzahl weiterer Funktionen implementiert werden müssen bevor sie als DSGVO konform eingestuft werden kann und somit zum Einsatz in der Praxis zugelassen wird.
    Das Matrix Protokol unterstützt den Großteil der notwendigen Implementierungen um DSGVO konform zu werden.
    Die einzige nicht unterstützte Funktionalität die während der Implementation entdeckt wurde ist das Löschen von Nachrichten bzw. Inhalten auf dem Server.
    Hierzu wird vom Protokol zur Zeit noch keine Möglichkeit bereitgestellt und somit muss ein eigenes System zum Löschen der Daten entwickelt werden.
    Es ist jedoch möglich über ein \texttt{m.room.redaction} Event den Inhalt einer Nachricht unkenntlich zu machen.\\
    Zwar sind alle Nachrichten und Daten die in einem Raum versendet wurden Verschlüsselt und vor unbefugtem Zugriff geschützt, allerdings ist es dem Betreiber der Plattform möglich, die Mitgliedschaften von Nutzern zu Räumen einzusehen.
    Somit könnte abgeleitet werden, welche Personen welche Ärzte besuchen.
    Ob dies zulässig ist müsste separat untersucht werden.

%    Zwar wurde während der Implementierung darauf geachtet, dass jegliche Daten zwischen Arzt und Patient verschlüsselt und vor unbefugtem Zugriff geschützt sind, jedoch müsste die genaue Rechtslage zum Einsatz der Plattform genauer untersucht werden.
%    Das Userinterface der App erfüllt zwar die gesetzten Ansprüche jedoch lässt das Design noch deutlich Platz für Verbesserungen.
%    Alle im Kapitel~\ref{sec:anforderungen} als 'Must' definierten Funktionen sind implementiert.
%    Ebenfalls wurden alle Anforderungen aus der

    \chapter{Ausblick}\label{ch:ausblick}
    Der nächste Schritt in der Entwicklung der Plattform sollte es sein, die Cross-Signing-Funktion der End-to-End Verschlüsslung zu unterstützen.
    Hierzu muss ein geeignetes Key-Management-System implementiert werden, welches es ermöglicht ein Gerät von einem anderen zu verifizieren und die Private Keys die zur Verschlüsselung der Nachrichten verwendet wurden zwischen den Geräten zu synchronisieren.
    Darüber hinaus sollte eine Prozess implementiert werden der es ermöglicht auch ohne Zugriff auf eines der anderen Geräte die verwendeten Schlüssel wiederherzustellen.
    Somit könnte beispielsweise bei Verlust oder bei Beschädigung des Gerätes trotzdem noch auf bestehende Chat-Verläufe zugegriffen werden.
    Mittels des Recovery Services des Crypto Moduls kann ein Backup der Session Keys auf der Server angelegt werden, welches über einen Recovery Key oder eine Passphrase geschützt werden kann.
    Von diesem Backup können dann bei Bedarf alle gespeicherten Keys wiederhergestellt werden.
    Die Dokumentation hierfür ist noch in der Erstellung~\cite{advancede2e} was die Implementation zum aktuellen Zeitpunkt deutlich erschwert.\\
    Es sollte ein System zum lokalen Speicher der Daten entwickelt werden, welches es möglich macht die Anwendung auch ohne Verbindung zum Internet einsehen zu können.
    Hierbei muss darauf geachtet werden die Daten verschlüsselt und separat vom allgemeinen Speicherbereich des Endgeräts abzulegen.
    Außerdem werden dadurch Ladezeiten reduziert und der Datentransfer zwischen Server und Anwendung zu minimiert.\\
    Des weiteren kann die Plattform um zusätzliche Nachrichtentypen erweitert werden.
    Es könnte beispielsweise das Aufnehmen und versenden von Audiodateien hinzugefügt werden.
    Außerdem kann der Datei-Message-Typ um weiter Dateitypen erweitert werden.

%    Außerdem könnte ein zusätzlicher Layer implementiert werden, welcher es ermöglicht Informationen über beigetretene Räume und deren jeweilige Konversationen geschützt auf dem Gerät zu speichern.
%    Somit hat der User auch ohne bestehende Verbindung zum Internet, Zugriff auf seine Konversationen und mögliche geteilter Daten.
%    Ferner sollten zusätzliche Dateitypen für Nachrichten unterstützt werden um es
%
%    Des weiteren könnte untersucht werden ob der Synapse Server in der LAge ist den Registrierungstoken über einen SMTP Server direkt an den User zu schicken nach vorheriger angabe einer emailadresse.

%\include{source/content/Test}

%Das Fazit
%\include{source/content/Fazit}
%Einbinden des Abbildungsverzeichnisses

    \backmatter
%Liste der Tabellen
    \listoftables
%Einbinden des Tabellenverzeichnisses
    \listoffigures
%Einbinden des Sourcecodeverzeichnisses
%\lstlistoflistings

% Quellenverzeichnis
    \bibliographystyle{abbrvnat}
    \bibliography{Bachelorarbeit}

% Anhang
    \appendix

\end{document}



%
% EOF
%