\newcommand{\DeinName}{Pascal Fischer}
\newcommand{\MatrNo}{371778}
\newcommand{\TitelArbeit}{Entwicklung einer verschlüsselten Chat-basierten Plattform auf Basis des Matrix.org-Protokolls im Kontext von digitaler Gesundheit und Telemedizin}
\newcommand{\Fachgebiet}{Regelungssysteme}
\newcommand{\PrueferEins}{Dr.-Ing Thomas Schauer}
\newcommand{\PrueferZwei}{Prof.-Dr.-Ing. Clemens Gühmann}
\newcommand{\fachbereich}{Elektrotechnik und Informatik}

% entweder ein Datum h?ndisch eintragen, oder den Befehl \today nutzen
\newcommand{\Datum}{\today}

\makeglossary


%
% Einbinden des Headers, hier k?nnen auch weitere Einstellungen vorgenommen werden.
\input{source/header}

\graphicspath{ {./source/images/pictures/} }

\lstdefinelanguage{json}{
    numbers=left,
    numberstyle=\small,
    frame=single,
    rulecolor=\color{black},
    showspaces=false,
    showtabs=false,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{gray}\hookrightarrow\space}},
    breakatwhitespace=true,
    basicstyle=\ttfamily\small,
    upquote=true,
    morestring=[b]",
    stringstyle=\color{string},
    literate=
    *{0}{{{\color{numb}0}}}{1}
        {1}{{{\color{numb}1}}}{1}
        {2}{{{\color{numb}2}}}{1}
        {3}{{{\color{numb}3}}}{1}
        {4}{{{\color{numb}4}}}{1}
        {5}{{{\color{numb}5}}}{1}
        {6}{{{\color{numb}6}}}{1}
        {7}{{{\color{numb}7}}}{1}
        {8}{{{\color{numb}8}}}{1}
        {9}{{{\color{numb}9}}}{1}
        {\{}{{{\color{delim}{\{}}}}{1}
        {\}}{{{\color{delim}{\}}}}}{1}
        {[}{{{\color{delim}{[}}}}{1}
        {]}{{{\color{delim}{]}}}}{1},
}


\newcommand\YAMLcolonstyle{\color{red}\mdseries}
\newcommand\YAMLkeystyle{\color{black}\bfseries}
\newcommand\YAMLvaluestyle{\color{blue}\mdseries}

\makeatletter

% here is a macro expanding to the name of the language
% (handy if you decide to change it further down the road)
\newcommand\language@yaml{yaml}

\expandafter\expandafter\expandafter\lstdefinelanguage
\expandafter{\language@yaml}
{
    keywords={true,false,null,y,n},
    keywordstyle=\color{darkgray}\bfseries,
    basicstyle=\YAMLkeystyle,                                 % assuming a key comes first
    sensitive=false,
    comment=[l]{\#},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{purple}\ttfamily,
    stringstyle=\YAMLvaluestyle\ttfamily,
    moredelim=[l][\color{orange}]{\&},
    moredelim=[l][\color{magenta}]{*},
    moredelim=**[il][\YAMLcolonstyle{:}\YAMLvaluestyle]{:},   % switch to value style at :
    morestring=[b]',
    morestring=[b]",
    literate =    {---}{{\ProcessThreeDashes}}3
        {>}{{\textcolor{red}\textgreater}}1
        {|}{{\textcolor{red}\textbar}}1
        {\ -\ }{{\mdseries\ -\ }}3,
}

% switch to key style at EOL
\lst@AddToHook{EveryLine}{\ifx\lst@language\language@yaml\YAMLkeystyle\fi}
\makeatother

\newcommand\ProcessThreeDashes{\llap{\color{cyan}\mdseries-{-}-}}


% Beginn des Dokuments
\begin{document}

%Zitiert alle Referenzen, ohne Sie hier zu listen. Dadurch erscheinen alle Quellen im %Literaturverzeichnis, auch wenn sie im Text nicht genutzt werden.
%Bitte nur f?r Testzwecke verwenden.
    \nocite{*}


% Einbinden des Deckblatts

    \frontmatter
    \include{source/Titelseite}
    \hypersetup{pageanchor=false}

    \newpage
    \section*{Zusammenfassung}
    In dieser Arbeit befasse ich mich mit ....

    \section*{Abstract}\label{sec:abstract}
    This paper describes how to ...
    \newpage
    \chapter*{Eidesstattliche Erklärung}\label{ch:eidesstattliche-erklarung}
    Hiermit erkläre ich, dass ich die vorliegende Arbeit selbstständig und eigenhändig sowie ohne
    unerlaubte fremde Hilfe und ausschließlich unter Verwendung der aufgeführten Quellen und
    Hilfsmittel angefertigt habe.\\
    \vspace{1cm}\\
    Berlin, den \underline{\hspace{3cm}} \hfill \DeinName \underline{\hspace{4cm}}

    \newpage
    \tableofcontents

    \mainmatter

    \newpage
    \chapter{Einleitung}\label{ch:einleitung}

    \section{Motivation}\label{sec:motivation}
    Mit voranschreiten der Digitalisierung
    Im Zuge der Coronapandemie im Jahre 2019 wurden nicht nur die Rufe nach

    \newpage
    \section{Zielsetzung}\label{sec:zielsetzung}
    Ziel dieser Arbeit ist es eine Plattform zu entwickeln welchen es Ärzten und Patienten ermöglicht in Kontakt zu treten und Nachrichten auszutauschen.
    Hierfür soll eine Chat-App auf basis des Matrix.org-Protokolls implementiert werden.
    Die App ist in der Programmiersprache Swift zu entwickeln und soll auf allen gängigen iOS geräten unterstützt werden.
    Darüber hinaus muss die benötigte Infrastruktur bereitgestellt werden um Nachrichten und Daten zu speichern und zu übermitteln.
    Diese soll jedoch isoliert laufen und nicht an das existierende Matrix Netzwerk angeschlossen werden.
    Da medizinische Daten dem Datenschutz in besonderer Maße unterliegen ist es besonders wichtig,
    dass jegliche Art von Kommunikation zwischen Ärzten und Patienten stets verschlüsselt ist.
    Es muss gewährleistet sein, dass zu jedem Zeitpunkt alle personenbezogenen Daten vor dem Zugriff unerlaubter Dritter geschützt sind.
%    Da es im Bereich der Medizin  hinaus ist zu beachten, dass das Userinterface
%    So sollte beispielsweise darauf geachtet werden, dass Da es im Bereich der Medizin hinaus ist zu beachten, dass das Userinterface
%    So sollte beispielsweise darauf geachtet werden, dass

    \section{Aufbau der Arbeit}\label{sec:aufbau-der-arbeit}
    Zuerst werden die gesetzlichen Ansprüche an eine Messaging-Plattform im medizinischen Bereich beleuchtet.
    Anschließend wird das Matrix Protokoll vorgestellt und seine allgemeine Funktionsweise beschrieben.
    Außerdem werden die zur Verschlüsselung verendeten Algorithmen erklÄrt und die dafür verwendeten Schlüssel aufgezeigt.
    Es werden die zur Implementierung der Plattform genutzten Technologien vorgestellt und deren Verwendung beschrieben.
    Danach werden einige ähnlicher Projekte vorgestellt und analysiert.
    Basierend auf dieser Analyse werden eine eine Reihe von technischen Anforderungen definiert welche von der implementierten Plattform erfüllt werden sollen.
    Anschließend wird die implementierte Plattform vorgestellt und deren Funktionsweise erklärt.
    Abschließend wird Plattform unter betrachtung der definierten Anforderungen evaluiert.

    \newpage
    \chapter{Theoretische Grundlagen}\label{ch:theoretische-grundlagen}
    In diesem Kapitel werden zunächst die theoretischen Grundlagen, welche die Implementierung der Plattform beeinflusst haben, vorgestellt.
    Anschließend wird das Matrix Protokoll vorgestellt und seine grundlegenden Prinzipien und Funktionsweise eingegangen..
    Außerdem werden die zur Verschlüsselung genutzten Algorithmen erklärt.

    \section{Datenschutz im Gesundheitswesen}\label{sec:datenschutz-im-gesundheitswesen}
    Die Rechtlichen Rahmenbedingungen für das Speicher und Verarbeiten medizinischer Daten sind in der EU-Datenschutz-Grundverordnung\footnote{https://dsgvo-gesetz.de/} (DSGVO) festgelegt.
    Diese fordert ebenfalls zur Einhaltung des IT-Sicherheitsgesetzes und des E-Health-Gesetzes auf.
    Medizinische Daten werden vom Gesetzgeber im besonderem Maße geschützt, da sie besonders sensible Informationen enthalten~\cite{datenschutzimgesundeitswesen}.

    \textit{Das am 29. Dezember 2015 in Kraft getretene "Gesetz für sichere digitale Kommunikation und Anwendungen im Gesundheitswesen (E-Health-Gesetz)" hat die ersten Weichen für den Aufbau der sicheren Telematikinfrastruktur (TI) und die Einführung medizinischer digitaler Anwendungen gestellt.
    Ziel dieses Gesetzes war es, die Chancen der Digitalisierung für die Gesundheitsversorgung zu nutzen und eine schnelle Einführung medizinischer Anwendungen für die Patientinnen und Patienten zu ermöglichen.}~\cite{ehealthgesetz}

    Ein Teil der Telematikinfrastruktur ist der TI-Messenger der Gematik GmbH welcher im Abschnitt~\ref{subsec:ti-messenger} genauer betrachtet wird.
    Am 07.11.2019 hat dann die Konferenz der unabhängigen Datenschutzaufsichtsbehörden des Bundes und der Länder ein Whitepaper veröffentlicht welche die "Technischen Datenschutzanforderungen an Messenger-Dienste im Krankenhausbereich" aus Sicht der DSGVO offenlegt.
    Einige dieser Anforderungen sind:
    \begin{enumerate}[label={(\arabic*)}]
        \item Die Applikation muss über die Möglichkeit verfügen, die Nutzung bzw. den Zugriff
    auf die darüber gespeicherten Daten an eine eigene vorherige Authentifizierung (z.B.
    PIN, Fingerabdruck etc.) zu knüpfen
        \item Die Applikation muss über die Möglichkeit verfügen, Kontaktdaten von
    Kommunikationsteilnehmern in einem eigenen, vom allgemeinen Adressbuch des
    Smartphones getrennten Speicher abzulegen.
        \item Sie muss weiterhin über die Möglichkeit verfügen,
    Nachrichten sowie Dateianhänge wie Bilder, Videos, Dokumente etc. ausschließlich
    in einem eigenen, von den allgemeinen Speicherbereichen des Smartphones
    getrennten Speicher in verschlüsselter Form abzulegen
        \item Eine Kommunikation über die Messenger-Applikation sollte nur auf
    der Grundlage einer verlässlichen Identifizierung und Authentifizierung der
    Kommunikationspartner möglich sein
        \item Werden elektronische Signaturen oder andere elektronischer Zertifikate genutzt,
    muss ein Zertifikatsmanagement vorhanden sein. Dies beinhaltet die Sicherstellung,
    dass elektronische Schlüssel oder Zertifikate eindeutig einer juristischen oder
    natürlichen Person zugeordnet werden, aber auch die Überprüfung der Gültigkeit der
    elektronischen Schlüssel bzw. Zertifikate. Insbesondere müssen kompromittierte
    Schlüsseln bzw. Zertifikate bzw. unbrauchbar gemacht werden können
        \item Die Applikation muss über die Möglichkeit verfügen, die über sie verwalteten Daten
    gezielt oder allgemein zu löschen.
        \item Soweit die Speicherung unter Einhaltung von Art. 28 DS-GVO durch einen Dienstleister übernommen wird, welcher nicht die Anforderungen des Art. 9 Abs. 3 DS-GVO erfüllt,
    muss die Möglichkeit bestehen, die Daten nach dem Stand der Technik vor ihrer
    Übergabe derart zu verschlüsseln, dass eine Entschlüsselung nur mit einem
    Schlüssel möglich ist, der nicht an den Dienstleister offenbart und separat gesichert
    wird.
        \item Die Vertraulichkeit und Integrität der über den Messenger-Dienst geführten
    ärztlichen Kommunikation muss unter Berücksichtigung des Stands der Technik
    über eine Ende-zu-Ende-Verschlüsselung zwischen den
    Kommunikationsteilnehmern gewährleistet werden
    \end{enumerate}


    \newpage
    \section{Matrix}\label{sec:matrix}

    \subsection{Matrix Protokoll}\label{subsec:matrix-protokoll}
    Das Matrix Protokoll ist ein offener Standard für dezentrale Echtzeitkommunikation im Internet.
    Es ist ein Open-Source-Projekt welches unter Aufsicht der Matrix.org Foundation, einer Non-Profit-Organisation aus England, entwickelt wird.
    Das Team besteht aus 12 Personen, viele von ihnen mit weitreichenden Erfahrungen im Bereich VoIP- und Messaging-Apps für Mobilgeräte.
    Die Entwicklung begann im Jahr 2014 und ist seit Juni 2019 für den Einsatz im Produktionsbetrieb geeignet.
    Mittlerweile gibt es zahlreiche Beiträge aus der Community, wodurch das Projekt weiter vorangetrieben wird.
    ~\cite{matrixfaq}

    Das ursprüngliche Ziel des Projektes war es ein Protokoll zu entwickeln, welches es Usern ermöglichen soll, anderen Usern Nachrichten zu schreiben oder diese anzurufen, unabhängig davon welche Platform diese benutzen.
    Langfristig soll Matrix ein generisches System zur Messaging und Datensynchronisation über HTTP für das ganze Internet bilden.
    ~\cite{matrixfaq}

    Hierzu definiert Matrix eine Reihe von REST-APIs:
    \begin{description}[leftmargin=!,labelwidth=5.5cm]
        \item [Client-Server-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/client-server-api/} zur Kommunikation zwischen Matrix kompatiblen Clients und einem Homeserver
        \item [Server-Server-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/server-server-api/} zum Nachrichtenaustausch und Synchronisation zwischen mehreren Homservern
        \item [Application-Service-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/application-service-api/} zur Erweiterung der Funktionalität von Matrix und Integration anderer Systeme
        \item [Identity-Service-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/identity-service-api/} beschreibt das Mapping zwischen Drittanbietern
        \item [Push-Gateway-API\footnotemark] \footnotetext{https://spec.matrix.org/v1.4/push-gateway-api/} um versenden von Push Notifications an Clients falls neue Events beim Homeserver eintreffen
    \end{description}



    \subsection{Funktionsweise}\label{subsec:funktionsweise}
%
%\usetikz
%\begin{figure}
%    \centering
%    \input{source/diagrams/matrix.tikz}
%    \caption{Beispielsituation}
%    \label{fig:matrixfunktionsweise}
%\end{figure}

    \subsection{Events}\label{sec:events}
    Jeglicher Datenaustausch im Matrix Protokoll wird als Event bezeichnet.
    Dies können


    Im Matrix Protokoll werden alle Ereignisse (Events) in einer einzigen großen Kette (Timeline) gespeichert. Diese Events können in zwei Kategorien unterteilt werden. Zum einen gibt es State Events, welche Ereginsse wie die Erzeugung eines Raumes oder das Beitreten eines Users zu einem Raum beschreiben.
    Zum anderen gibt es Message Events welche realen Datenaustausch zwischen Usern beschreiben. Dies können beispielsweise Textnachrichten, Fotos oder Videos sein. Jedes Event enthält unter anderem folgende Attribute:
    \begin{description}[leftmargin=!,labelwidth=3.5cm]
        \item [event\_id] ein eindeutiger Identifier für das jeweilige Event
        \item [sender] die Matrix ID des Absenders des Events
        \item [room\_id] ein eindeutiger Identifier über welchen ein Event einem bestimmten Raum zugeordnet werden kann
        \item [type] der Typ des Events
        \item [content] der tatsächliche Inhalt der Nachricht. Dieser variiert abhängig vom event Type
        \item [origin\_server\_ts] Zeitstempel
    \end{description}

    \subsection{Rooms}


    \begin{lstlisting}[language=json,firstnumber=1]
{"menu": {
  "id": "file",
  "value": "File",
  "popup": {
    "menuitem": [
      {"value": "New", "onclick": "CreateNewDoc()"},
      {"value": "Open", "onclick": "OpenDoc()"},
      {"value": "Close", "onclick": "CloseDoc()"}
    ]
  }
}}
    \end{lstlisting}


    \subsection{Devices}
    Ein Device im Matrix Protokoll beschreibt weniger ein reales Gerät wie ein Computer oder Smartphone sondern viel mehr eine Instanz eines Matrixclients auf einem Gerät.
    So können beispielsweise mehrere Anwendungen auf einem Gerät installiert sein und jedes wäre sein eigenes Device.
    Jedes Device bekommt seine eigene \texttt{device\_id} zugewiesen.
    Dabei ist zu beachten, dass falls sich ein User von einer Anwendung abmeldet und sich auch dem selben Gerät bei der selben Anwendung erneut anmeldet nicht die gleiche \texttt{device\_id} zugewiesen bekommt.
    Je nach Client wird eine somit unterschiedlich häufig die \texttt{device\_id} gewechselt.
    In Webanwendungen wird bei jedem Anmelden ein neue \texttt{device\_id} angelegt wohingegen bei Client auf Mobilgeräten oder Computern die gleiche \texttt{device\_id}
    Devices finden hauptsächlich Anwendung

    \newpage
    \subsection{End-to-End-Encryption}\label{subsec:verwendete-schlussel}
    Zur Verschlüsselung von Nachrichten werden der Olm und der Megolm Algorithmus verwendet.\\
    Der Olm Algorithmus ist ein Double-Ratchet-Algorithmus.
    Er wird dafür genutzt verschlüsselte Nachrichten zwischen 2 Parteien auszutauschen, wobei mit jeder Nachricht ein neuer Key zur Verschlüsselung abgeleitet wird.
    Dies geschieht durch verkettung einer Key Derivation Function (KDF).
    Hierbei werden 3 Ketten geführt, die root chain, sending chain und receiving chain.
    Die sending chain einer Partei gleicht der receiving chain der anderen Partei und andersrum~\cite{perrin2016double}.
    Für die Erstellung des Wurzelknotens werden 4 Keys benötigt.
    Man benötigt die Identity Keys beider Teilnehmer ($I_A$ und $I_B$) und jeweils einen Curve25519 one-time key ($E_A$ und $E_B$).
    Mithilfe des Diffie-Hellman-Verfahrens wird ein gemeinsamer geheimer Schlüssel S erzeugt.
    Zur Berechnung dieses Schlüssels wird die Elliptic Curve Diffie-Hellman (ECDH) angewendet.
    \begin{displaymath}
        S = ECDH(I_A,E_B)\parallel ECDH(E_A,I_B) \parallel ECDH(E_A,E_B)
    \end{displaymath}
    Aus diesem geheimen Schlüssel lassen sich dann mittels HKDF-SHA-256 der Chain-Key $C_{0,0}$ und der Root Key $R_0$ ableiten.
    \begin{displaymath}
        R_0 \parallel C_{0,0} = HKDF(0,S,"OLM\_ROOT",64)
    \end{displaymath}
    Mit diesen Keys können anschließend alle fortlaufenden Keys berechnet werden~\cite{olm}.
    Der berechnete Schlüssel der root chain wird als input der KDF für die sending bzw. receiving chain genutzt.
    Der hierbei entstehende schlüssel ird zum Verschlüsseln der eigentlichen Nachricht genutzt.
    Somit erfüllt der Olm Algorithmus folgende Eigenschaften:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [Resilience] wird benutzt um ein Gerät zu identifizieren. Jedes Device besitzt seinen eigenen Ed25519 Schlüssel.
        \item [Forward security] wird genutzt um den gemeinsamen geheimen Schlüssel zu erstellen.
        \item [Break-in recovery] ein Set von einmal verwendbarer Keys um Aufbau einer Olm Sitzung.
    \end{description}

    Der Megolm Algorithums wird zur Verschlüsslung von Gruppen-Chats verwendet.
    Es ist ein auf dem Advanced Encryption Standard (AES) basierender Ratchet-Algorithmus~\cite{megolm}.

    Zusammengefasst werden folgende Schlüssel für die End-to-End-Verschlüsselung im Matrix Protokoll benötigt:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [Ed25519 fingerprint key pair] wird benutzt um ein Gerät zu identifizieren. Jedes Device besitzt seinen eigenen Ed25519 Schlüssel.
        \item [Curve25519 identity key pair] wird genutzt um den gemeinsamen geheimen Schlüssel zu erstellen.
        \item [Curve25519 one-time keys] ein Set von einmal verwendbarer Keys um Aufbau einer Olm Sitzung.
        \item [Megolm encryption keys] wird benutzt um Nachrichten in Gruppen-Chats zu verschlüsseln.
        \item [Ed25519 Megolm signing key pair] Schlüssel zum Signieren von Nachrichten in Gruppen-Chats, dient der Authentifizierung des Absenders.
    \end{description}
    ~\cite{matrix-end-to-end-encryption}



    \section{REST-API}\label{sec:rest}

    \cite{dazer2012restful}

    \newpage
    \section{Anwendungsarchitektur}\label{sec:anwendungsarchitektur}
    Wie im Bereich von Webapplications haben sich auch im Bereich von Mobile Apps über die Zeit bestimmte Anwendungsarchitekturen (Design Patterns) entwickelt.
    Diese dienen als Muster um wiederkehrende Entwurfsprobleme zu lösen, indem man auf bewährte Praktiken zurückgreift.
    Sie beschreiben die allgemeine Struktur der Anwendung und geben somit auch die Aufteilung des Quellcodes vor.
    Die richtige Wahl der Anwendungsarchitektur kann einen entscheidenden Einfluss darauf nehmen wie effizient die Entwicklung des Projektes verläuft.
    Darüber hinaus erleichtern sie die Arbeit im Team da sie ein einheitliches Vokabular bieten.
    Im Folgenden werden 3 der bekanntesten Architekturen für Mobile Apps näher erläutert.

    \newpage
    \subsection{Model-View-Controller}\label{subsec:model-view-controller}
    Die Model-View-Controller Architektur teilt eine Anwendung in 3 Bereiche auf welche in Abbildung~\ref{fig:mvc} dargestellt sind.

    \begin{figure}[h]
        \centering
        \input{source/diagrams/mvc.tikz}
        \caption{Interaktionen im Model-View-Controller}
        \label{fig:mvc}
    \end{figure}

    Das \textbf{Model} repräsentiert die Struktur der Daten und hält Informationen über den aktuellen Zustand der Anwendung.
    Außerdem ist es verantwortlich für die Kommunikation mit externen Datenquellen wie beispielsweise Datenbanken.
    ~\cite{mvc}
    Es liefert die Daten an die View weiter, ohne diese zu verändern.
    Die Daten im Model sind somit unabhängig von ihrer Präsentation.
    Deshalb ist es möglich mehrere Views an dasselbe Model, und somit dieselben Daten zu binden.
    Hierbei sind jedoch die Präsentationen der Daten auf den einzelnen Views ebenfalls unabhängig voneinander.
    Sollten sich die Daten im Model ändern werden die Views über diese Änderung informiert~\cite{https://doi.org/10.48550/arxiv.1408.5786}.

    Die \textbf{View} stellt die optische Oberfläche der Anwendung dar.
    Sie enthält alle grafischen Elemente wie Textfelder, Bilder oder anderer Elemente die zur Darstellung der Daten aus dem Model benötigt werden.
    Zudem nimmt sie die Eingaben des Users entgegen und leitet diese an den Controller weiter~\cite{https://doi.org/10.48550/arxiv.1408.5786}.


    Der \textbf{Controller} ist für die Steuerung der Anwendung zuständig.
    Seine Aufgabe ist es je nach Eingabe des Benutzers das Model manipulieren.
    Basierend auf der Eingabe des Benutzers ist er ebenfalls dafür zuständig die aktuelle View zu wechseln~\cite{https://doi.org/10.48550/arxiv.1408.5786}.


    Im Model-View-Controller Pattern sind Programmlogik, Datenstruktur und die Präsentation der Daten derart getrennt, dass es möglich ist diese Unabhängig voneinander zu verändern, ohne damit Einfluss auf einen der anderen Bereiche zu nehmen.
    Somit ist es möglich beispielsweise die Oberfläche eines Programmes zu überarbeiten, ohne sich dabei Gedanken über die darunter liegende Ausführungslogik zu machen~\cite{mvc}.

    \subsection{Model-View-Presenter}\label{subsec:model-view-presenter}
    Die Model-View-Presenter Architektur ist eine weiterentwicklung der Model-View-Controller Architektur und dieser somit sehr ähnlich.
    Sie ist ebenfalls in 3 Bereiche geteilt, die View und das Model übernehmen die gleichen Funktionieren wie auch schon in der Model-View-Controller Architektur.
    Entscheidender Unterschied hierbei ist jedoch, dass View und Controller nicht direkt miteinander verbunden sind.
    Wie in Abbildung~\ref{fig:mvp} zu sehen werden Model und View über den Presenter verbunden.
    Dieser ersetzt den Controller und fungiert als Schnittstelle beider Komponenten.
    Die über die View eintreffenden Eingaben der Users werden vom Presenter verarbeitet und damit das jeweilige Model manipuliert.
    Das daraus resultierende aktualisierte Model wird dann vom Presenter zurück an die View geschickt um diese zu aktualisieren~\cite{mvp1}.
    \begin{figure}[h]
        \centering
        \input{source/diagrams/mvp.tikz}
        \caption{Interaktionen im Model-View-Presenter}
        \label{fig:mvp}
    \end{figure}

    Durch diesen Aufbau haben View und Model klar definierte Schnittstellen, welche vom Presenter miteinander verbunden werden.
    Im Vergleich zur Model-View-Controller Architektur erhält man somit eine noch deutlichere Trennung der einzelnen Komponenten~\cite{mvp2}.

    \subsection{Model-View-ViewModel}\label{subsec:model-view-viewmodel}
    Die Model-View-ViewModel Architektur ist ebenfalls eine weiterentwicklung der Model-View-Controller Architektur.


    \begin{figure}[h]
        \centering
        \input{source/diagrams/mvvm.tikz}
        \caption{Interaktionen im Model-View-Presenter}
        \label{fig:mvvm}
    \end{figure}

    \cite{Anderson2012}
%    \cite{Hoefling2022}

    \chapter{Verwendete Technologien}\label{ch:verwendete-technologien}
    In diesem Kapitel werden die für die Implementierung der Plattform verwendeten Technologien vorgestellt.
    Es wird auf deren Funktionsweise eingegangen und ihre Verwendung in der Entwicklung der Plattform erklärt.


    \section{XCode}\label{sec:xcode}
    XCode\footnote{https://developer.apple.com/xcode/} ist eine von Apple bereitgestellte Entwicklungsumgebung für die Entwicklung von Anwendungen für Apple Betriebssysteme, darunter iOS.
    Sie ist für die Programmierung in Swift und Objective-C vorgesehen~\cite{xcode}.
    Sie stellt eine Reihe von Templates zur Verfügung die bei der Erstellung des Projektes helfen können.
    Für die Entwicklung der Plattform wurde die aktuelle Version XCode 14 verwendet.
    Diese kann aus dem Appstore heruntergeladen werden.

    \section{Simulator}\label{sec:simulator}
    Der Simulator wird zusammen mit XCode installiert und ermöglicht das Simulieren und Testen der entwickelten App.
    Er ist direkt in XCode integriert und erlaubt es das Programm über den debugger zu analysieren.
    Darüber hinaus sendet er log-Messages zurück an XCode welche ebenfalls zum Überwachen der Anwendung genutzt werden können.


    \section{Swift}\label{sec:swift}
    Swift\footnote{https://developer.apple.com/swift/}

    \cite{Goodwill2015}

    \section{SwiftUI}
    SwiftUI\footnote{https://developer.apple.com/xcode/swiftui/} ist ein GUI-Toolkit zur

    \cite{Cahill2021}
    \cite{Varma2019}


    \newpage
    \section{Cocoapods}\label{sec:cocoapods}
    CocoaPods\footnote{https://github.com/CocoaPods/CocoaPods} ist ein Dependency Manager für Objective-C und Swift Projekte.
    Es ermöglicht dem Entwickler Quellcode von verschiedenen Orten in ein Projekt einzubinden.
    Hierzu können über 92.000 Libraries verwendet werden.
    Besonders im Bereich von Mac OSX und iOS Development findet das Tool häufig Verwendung.
    CocoaPods unterstützt sowohl private als auch öffentliche Repositories über git, svn, brz, http und hg.
    Hierbei ist zu beachten, dass das nicht jedes Repository automatisch über Cocoapods eingebunden werden kann.
    Es muss zuerst ein Pod aus der jeweiligen Library erstellt werden.
    Das seit 2014 entwickelte Projekt ist Open Source und wurde seit dem von über 300 Entwicklern stetig verbessert.
    Es ist ein Kommandozeilen-Tool welches in Ruby implementiert wird.
    Somit kann es über den RubyGems Paketmanager heruntergeladen werden.
    Hierzu kann nach erfolgreicher Installation von Ruby folgendes Kommando in der Konsole ausgeführt werden:
    \begin{lstlisting}[language=bash,label={lst:cocoapods}]
        $ sudo gem install cocoapods
    \end{lstlisting}
    Mittels CocoaPods lassen sich dann alle benötigten Libraries im sogenannten Podfile definieren und importieren.
    Das Podfile ist eine einfache Textdatei in welcher die Zielplattform und eine Liste aller benötigter Libraries und ihrer jeweiligen Versionen angegeben wird.
    In Listing\ref{lst:podfile} ist die Struktur eins solchen Podfiles zu sehen.
    ~\cite{cocoapods1, cocoapods2, cocoapods3}
    \begin{lstlisting}[language={},firstnumber=1,label={lst:podfile},caption={Beispielstuktur eines Podfiles},captionpos=t]
platform :ios, '8.0'
use_frameworks!

target 'MyApp' do
  pod 'AFNetworking', '~> 2.6'
  pod 'ORStackView', '~> 3.0'
  pod 'SwiftyJSON', '~> 2.3'
end
    \end{lstlisting}


    \section{Matrix iOS SDK}\label{sec:matrix-sdk}
    Die Matrix iOS SDK \footnote{https://github.com/matrix-org/matrix-ios-sdk} ist eine Open Source Library welche zur für die Entwicklung Matrix basierter Anwendungen für iOS Geräte gedacht ist.
    Sie fungiert als Schnittstelle zwischen Client Application und Matrix Server.
    Hierzu werden die in der Client-Server-API definierten Operationen bereitgestellt.
    Um die Matrix SDK in ein Projekt einzubinden muss hierfür ein Eintrag im in Abschnitt~\ref{sec:cocoapods} erläuterten Podfile angelegt und installiert werden.
    ~\cite{matrixiossdk}
    \begin{lstlisting}[language={},label={lst:matrtix-sdk}]
        pod 'SwiftMatrixSDK'
    \end{lstlisting}
    Anschließend kann die Library im Swift Code importiert werden.
    \begin{lstlisting}[language=swift,label={lst:matrtix-sdk-swift}]
        import MatrixSDK
    \end{lstlisting}

    \section{Synapse}\label{sec:synapse}
    Synapse\footnote{https://github.com/matrix-org/synapse/} ist eine von der Matrix.org Foundation bereitgestellte Open Source Implementation eines Homeservers.
    Sie folgt den im Matrix Protokoll festgelegten REST-APIs.
    Die Entwicklung begann 2014 und kann seit 2019 im Produktivbetrieb genutzt werden.
    Der Homeserver ist in Python geschrieben und kann somit auf jedem beliebigen Host betrieben werden, es wird jedoch empfohlen einen von Matrix.org bereitgestellten Dockercontainer zu verenden.

    \section{Docker}\label{sec:docker}
    Docker ist eine Containervirtualisierungssoftware welche es ermöglicht Anwendung vom Rest des Systems zu isolieren.
    Auch wenn sie nach außen wie eine virtuelle Maschine wirkt, bietet sie entscheidende Vorteile.
    Herkömmliche virtuelle Maschinen bilden eine vollständige Kopie eines Betriebssystems welches mittels einer Virtualisierungssoftware wie beispielsweise Oracle VirtualBox oder KVM auf einem Hypervisor betrieben werden muss.
    Betrachtet man den vollständigen Stack einmal von unten hat man zuallererst die Hardware des Hypervisors, auf diesem läuft ein Betriebssystem, worauf wiederum die Virtualisierungssoftware läuft, mit welcher eine isolierte Kopie eines anderen Betriebssystems erzeugt wird in welcher die eigentliche Anwendung dann läuft.
    Dies sorgt für erhebliche Einbußen in der Performance.
    Docker Container sind in der Lage in wenigen Sekunden zu starten.
    Sie laufen direkt auf dem Betriebssystem des Hypervisors sind aber dennoch isoliert vom Rest des Systems.
    Dies geschieht mithilfe zweier Linux Kernel Technologien, namespaces und cgroups~\cite{docker}.
    Docker arbeitet mit Container und Images wobei ein Image eine Reihe von Befehlen darstellt um eine gewünschte Umgebung zu erschaffen.
    Ein Container ist eine laufende Instanz eines Images.


    \chapter{Konzept}\label{ch:konzept}
    In diesem Kapitel werden 2 verwandte Projekte analysiert und unter Betrachtung der Zielgruppe einige Anforderungen definiert die die App zu erfüllen hat.

    \section{Ähnlicher Projekte}\label{sec:analyse-ahnlicher-projekte}

    \subsection{TI-Messenger}\label{subsec:ti-messenger}

    \subsection{Nio}
    Nio\footnote{https://github.com/niochat/nio} ist ein vom User kiliankoe gestartetes Projekt.
    Es ist ein Open Source Projekt und läuft unter der Mozilla Public License 2.0.
    Das im Februar 2020 gestartete Projekt wurde seither von einer Vielzahl anderer User weiterentwickelt.
    Der Nio Client ist ein in Swift geschriebener Messenger zur Nutzung im Matrix Netzwerk.
    Er befindet sich aktuell in noch in einer Beta-Phase.
    Das Anmelden, Erstellen von Räumen und Versenden von Nachrichten ist bereits möglich.
    Es können sowohl Textnachrichten als auch Fotos versendet werden.
    Darüber hinaus kann auf Nachrichten mittels Emojis reagiert werden.
    Es werden direkte Chats und Räume mit mehreren Personen unterstützt.
    Das erstellen von Accounts über den Nio Client ist zum Zeitpunkt der Analyse noch nicht möglich.
    Ebenfalls wird auch keine End-2-End Verschlüsselung unterstützt.
    Darüber hinaus unterstützt der Nio Client eine Vielzahl von Sprachen.

    \newpage
    \section{Anforderungen}\label{sec:anforderungen}
    Nach der Analyse ähnlicher Projekte wurden eine Liste funktionaler Anforderungen erstellt die von der Plattform erfüllt werden müssen.
    Diese wurden nach der MoSCoW-Methode priorisiert.\\

    \textbf{Must}:
    \begin{enumerate}[label={\roman*.}, leftmargin=2.5cm]
        \item Der User muss über die App einen Account auf der Plattform anlegen können.
        \item Der User muss sich mit seinem Account in der App einloggen können.
        \item Der User muss sein Passwort ändern können.
        \item Dem User muss alle von beigetretenen Räume sehen können.
        \item Dem User muss neue Räume erstellen können.
        \item Der User muss zu neuen Räumen eingeladen werden können.
        \item Der User muss alle Nachrichten die in einem Raum gesendet wurden einsehen können.
        \item Der User muss Nachrichten in einem Raum senden können.
        \item Nachrichten zwischen Usern müssen End-to-End Verschlüsselt sein.
        \item Der User muss einen Raum verlassen können.
        \item Der User muss seinen Account deaktivieren können.
    \end{enumerate}


    \textbf{Should}:
    \begin{enumerate}[label={\roman*.}, leftmargin=2.5cm]
        \item Beim erstellen des Accounts soll eine zusätzliche Authentifizierungsmethode verwendet werden um Wahloses erstellen zon Accounts zu verhindern.
        \item Der User soll sich nur einmal einloggen müssen.
        \item Der User soll sich ausloggen können.
        \item Der Benutzer soll die Möglichkeit haben sein Profilbild und seinen Anzeigenamen anzupassen.
        \item Der vollständige Chat-Verlauf soll nur bei Bedarf geladen werden.
        \item Die App soll neben Textnachrichten auch andere Nachrichtentypen wie Fotos oder Videos unterstützen.
        \item Die App soll den User über den Erhalt einer neuen Nachricht informieren.
        \item Die Übersicht der beigetretenen Räume soll nach letzter Aktivität sortiert werden.
    \end{enumerate}


    \textbf{Could}:
    \begin{enumerate}[label={\roman*.}, leftmargin=2.5cm]
        \item Die Liste der beigetretenen Räume kann gefiltert werden.
        \item Dem Erstellen eines Raumes kann dem User eine Liste von Usern vorgeschlagen werden, welche dem gesuchten Namen entsprechen.
        \item Dem User kann ein Typing-Indikator gezeigt werden.
        \item Die App kann auch mit anderen Homeservern verbunden werden.
        \item Der User kann den Inhalt einer Textnachricht in die Zwischenablage kopieren.
        \item Der User kann eine Nachricht weiterleiten.
        \item Der User kann Dateien welche in einem Raum verschickt wurden herunterladen.
        \item Die App kann im Landscape mode genutzt werden.
    \end{enumerate}

    \textbf{Won't}:
    \begin{enumerate}[label={\roman*.}, leftmargin=2.5cm]
        \item Die App wird Räume und Chat-Verläufe nicht local speichern und offline wiedergeben können.
        \item Die App wird keine Nachrichten entschlüsseln können, die mit einem anderen Gerät versendet wurden.
    \end{enumerate}

    \newpage
    \chapter{Implementierung}\label{ch:implementierung}
    Dieses Kapitel beschreibt die Vorgehensweise bei der Implementierung der Plattform und die Funktionsweise der einzelnen Elemente.
    Die Plattform selbst besteht aus 2 Teilen.

    die Kommunikation zischen



    \section{App}\label{sec:app}
    Bei der Entwicklung der App wurde in 2 Etappen vorgegangen.
    Zuerst wurden basierend auf den in Abschnitt~\ref{sec:anforderungen} definierten Anforderungen mittels SwiftUI die benötigten Views erstellt.
    Hierbei musste darauf geachtet werden, dass die Elemente im Userinterface in ihrer Größe und Anordnung dynamisch blieben um sowohl auf kleineren Geräten wie dem iPhone 13 mini aber auch auf größeren Geräten wie dem Iphone 14 Pro Max bedienbar zu sein.
    Anschließend wurden die zugehörigen ViewModel angelegt und mit dem Elementen aus den Views verknüpft.
    Eine besondere Herausforderung hierbei war es, dass sich die grafischen Elemente bei eintreffen neuer Events ordnungsgemäß aktualisiert haben.


    \newpage
    \subsection{Login und Account Erstellung}\label{subsec:login-und-account-erstellung}

    Wenn die App das erste Mal gestartet wird gelangt man zuerst in die in Abbildung~\ref{fig:selecthomeserverview} zu sehende \texttt{SelectHomeserverView}.
    Diese View dient dazu sich mit dem Homeserver verbinden zu können.
    Sie spielt eine besondere Rolle während der Entwicklung da häufiger zwischen Entwicklungs- und Produktivumgebung gewechselt wurde.
    Der User hat die Möglichkeit den Homeserver mit welcher er sich verbinden möchte über den DNS-Adresse oder IP-Adresse zu erreichen.
    Des Weiteren kann der den Port des Homeservers angeben.
    Der default Port über den sich ein Client mit dem für Matrix Server verbindet ist 448 (und 8448 für die Kommunikation zwischen Servern untereinander).
    Für den Einsatz im Produktivbetrieb könnte diese View entfernt werden und die Adresse des Homeservers fest in der App festgelegt werden.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{homeserver}
        \centering
        \caption{SelectHomeserverView}\label{fig:selecthomeserverview}
    \end{figure}
%    \begin{wrapfigure}{R}{0.5\textwidth}
%        \begin{center}
%            \includegraphics[scale=0.5]{selecthomeserver}
%        \end{center}
%        \caption{SelectHomeserverView}\label{fig:selecthomeserverview}
%    \end{wrapfigure}
    Hat der User einen Homeserver eingetragen und klick auf connect prüft die App zuerst ob der Homeserver erreichbar ist.
    Hierzu wird eine Abfrage der Versionsnummer an den angegebenen Homeserver gesendet.
    Dies geschieht durch senden einer GET Anfrage an \texttt{/\_matrix/client/versions} (siehe Abschnitt~\ref{sec:rest}).
    Ist diese Anfrage erfolgreich wird der Homeserver im Model hinterlegt und der User gelangt zur \texttt{LoginView} welche in Abbildung ~\ref{fig:loginview} zu sehen ist.
    Falls die Anfrage fehlschlägt wird dem User eine Fehlermeldung gezeigt.
    \begin{figure}[h]
        \includegraphics[scale=0.5]{login}
        \centering
        \caption{LoginView}\label{fig:loginview}
    \end{figure}
    In dieser View kann der User sich entweder mit seinem bereits existierenden Account anmelden oder einen neuen Account erstellen.
    Für den Fall, dass der User bereits einen Account besitzt muss er seinen User namen und sein Passwort in die dafür vorgesehenen Felder eintragen und über den Login Button bestätigen.
    Das Passwortfeld ist hierbei ein \texttt{SecureField} welches die Eingabe versteckt und lediglich mit Punkten darstellt.
    Über das Auge am Rand des Textfeldes kann der User zwischen geschützter Ansicht und Klartext wechseln.


    Hat der User seine Zugangsdaten eingegeben und über den Login Button bestätigt wird über den \texttt{MXRestClient}, welcher von der SDK (siehe Abschnitt \ref{sec:matrix-sdk}) bereit gestellt wird, eine Login-Anfrage mit Usernamen und Passwort an den Server gesendet.
    Bei gültigen zugangsdaten enthält die Antwort des Servers folgende Informationen:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [home\_server] die vollständige Adresse des Homeservers
        \item [access\_token] ein Access Token zur weiteren Verwendung mit dem \texttt{MXRestClient}
        \item [user\_id] die vollständige Matrix ID des Users
        \item [device\_id] die vom Server zugewiesene ID für das Gerät
    \end{description}
    Die Information über \texttt{home\_server}, \texttt{user\_id} und \texttt{device\_id} werden in den \texttt{UserDefaults} der App gespeichert.
    Da der \texttt{access\_token} den Zugriff auf Benutzerkonto des Users ermöglicht, wird dieser mittels eines \texttt{KeychainHelper}\footnote{https://gist.github.com/LeeKahSeng/2452e90a57a5324de367907a36d88a49} in der iCloud Keychain gespeichert.
    Falls die Zugangsdaten nicht korrekt sind wird dem User erneut eine Fehlermeldung gezeigt.
    Anschließend wird mit diesen Information eine Matrix Session gestartet welche vollen Zugriff auf die Nutzerdaten
    War das starten der Session erfolgreich gelangt der User in die \texttt{RoomsView}.\\

    Für Den Fall das der User noch keinen Account besitzt kann über den Button "Create Account" der \texttt{LoginView} zur \texttt{CreateAccountView} gelangen welche in Abbildung~\ref{fig:createaccountview} dargestellt ist.
    Diese View dient der Account erstellung und enthält 3 Textfelder für Benutzernamen, Passwort und Registrierungstoken.
    Für das Passwortfeld kann wie schon in der \texttt{LoginView} zwischen versteckter Eingabe und Klartet gewechselt werden.
    \begin{figure}[h]
        \includegraphics[scale=0.5]{accountcreate}
        \centering
        \caption{CreateAccountView}\label{fig:createaccountview}
    \end{figure}
    Der Registrierungstoken kann über die Admin-API\footnote{https://matrix-org.github.io/synapse/latest/usage/administration/admin\_api/} des Servers erstellt werden.
    Hierzu muss eine GET-Anfrage an \texttt{/\_synapse/admin/v1/registration\_tokens/new} gesendet werden.~\cite{synapseregistartiontoken}
    Alternativ kann auch direkt in der Datenbank des Servers ein Token angelegt werden (im \texttt{registration\_tokens} table).
    Es werden folgende Felder bereitgestellt:
    \begin{description}[leftmargin=!,labelwidth=3cm]
        \item [token] Der Token der bei der Erstellung des Accounts angegeben werden muss.
        \item [uses\_allowed] Die maximale Anzahl an Accounts die mit einem Token erstellt werden kann.
        \item [pending] Anzahl laufender Registrierungen.
        Sie gibt an wie viele Benutzer die Authentifizierungsstufe mit dem Token bereits abgeschlossen haben ohne den vollständigen Registrierungsvorgang erfüllt zu haben.
        \item [completed] Anzahl erfolgreich erstellter Accounts mit diesem Token.
        \item [expiry\_time] Ablaufdatum des Tokens. Er gibt an wie lange der Token gültig ist.
    \end{description}

    Der eigentliche Registrierungsvorgang kann mehrere Authentifizierungsstufen enthalten.
    Bevor der Registrierungsvorgang gestartet wird ir zuvor mit der vom \texttt{MXRestClient} breitgestellten funktioin geprüft ob der Benutername bereit genutzt wird.
    In dieser Implementation wird der in Abbildung~\ref{fig:accountCreationDiagram} beschriebene dreistufige Accounterstellungsvorgang mittels eines Registriersungstokes genutzt.

    \begin{figure}[h]
        \centering
        \begin{sequencediagram}
            \newthread{A}{Client}{}
            \newinst[7]{B}{Server}{}
            \begin{sdblock}{Stage 1}{Receive Session ID}
                \begin{call}{A}{getRegistrationSession()}{B}{\shortstack{
                    return Session ID\\
                    return supported flows}}
                    \postlevel
                \end{call}
            \end{sdblock}
            \begin{sdblock}{Stage 2}{m.login.registration\_token}
                \begin{call}{A}{register()}{B}{}
                \end{call}
            \end{sdblock}
            \begin{sdblock}{Stage 3}{m.login.dummy}
                \begin{call}{A}{register()}{B}{}
                \end{call}
            \end{sdblock}
        \end{sequencediagram}
        \caption{Account erzeugungs Flow}
        \label{fig:accountCreationDiagram}
    \end{figure}

    Im ersten Schritt sendet der Client eine leere Anfrage zum Server in welcher er um das starten einer Registrierungssitzung bittet.
    Der Server antwortet daraufhin mit einer SessionID und den vom Homeserver unterstützten Authentifizierungss-Flows.
    In diesem Beispiel ist der einzige unterstützte Flow die verifizierung über einen Registriersungstoken.
    Im nächsten Schritt sendet der Client dann den zuvor bereitgestellten Registrierungstoken und die vom Server gegebene SessionID in Kombination mit der aktuellen Stufe des Authentifizierungsvorgangs.
    Im dritten und letzten Schritt wird nun der dummyflow aufgeführt.
    Dieser Flow kann nicht fehlschlagen und dient der zur finalen Erstellung des Account.
    Hierbei werden der gewünschte Benutername und Passort übergeben.
    Ist dies geschehen wurde der Account erfolgreich erstellt.
    Anschließend wird der User ebenfalls auf die \texttt{RoomsView} weitergeleitet.

    \newpage
    \subsection{Raumübersicht}\label{subsec:raumubersicht}

    Die \texttt{RoomsView} bildet das Herzstück der App.
    Sie ist die Ansicht die dem User bei jedem Start der App gezeigt wird sofern er sich bereits in der App angemeldet hat.
    Von dieser Ansicht aus können alle weiteren Views erreicht werden.
    Die in Abbildung~\ref{fig:roomsview} gezeigte View besteht aus einer \texttt{Toolbar} im Kopf der Ansicht über welche man zur \texttt{ProfileView} und \texttt{SettingsView} gelangt.
    Darunter findet sich die Raum übersicht welche alle beigetretenen Räume in einer scrollbaren Liste anzeigt.
    Jedes Element der Liste zeigt den das Profilbild des jeweiligen Raumes sowie Displayname oder Title des jeweiligen Raumes.
    Bei direkten Räumen wird außerdem die MatrixID des Users angezeigt.
    Auf der rechten Seite befindet sich der Zeitpunkt der letzten Nachricht und ein Indikator dafür ob und wie viele ungelesene Nachrichten im einem Raum existieren
    Über das darüberliegende Textfeld kann kann die Liste gefiltert werden.
    Darüber hinaus wird die Liste nach dem  \texttt{originServerTimestamp} der letzten Nachricht des jeweiligen Raumes sortiert.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{rooms}
        \centering
        \caption{RoomsView}\label{fig:roomsview}
    \end{figure}
    Über den Button mit dem Plus gelangt man zur \texttt{NewRoomView} in welcher man einen neun Raum erstellen kann.
    Im Fuß der View befindet sich eine TabView über welche zwischen \texttt{RoomsView} und \texttt{InvitesView} gewechselt werden kann.
    Die \texttt{InvitesView} welche in Abbildung~\ref{fig:invitesview} zu sehen ist dient dazu alle offenen Einladungen zu anderen Räumen aufzulisten.
    Diesen kann durch einfaches klicken auf den jeweiligen Raum beigetreten werden.
    Man gelangt dann zur \texttt{ChatView} und kann direkt mit dem jeweiligen Raum Kommunizieren.
    Falls man die Einladung ablehnen möchte kann man dies durch wischen der Einladung in Richtung des linken Bildschirmrandes tun.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{invites}
        \centering
        \caption{InvitesView}\label{fig:invitesview}
    \end{figure}

    \newpage
    \subsection{Raumerzeugung}\label{subsec:raumerzeugung}
    Hat der User in der \texttt{RoomsView} oder \texttt{InvitesView} auf den Plus-Button geklickt gelangt er in die \texttt{NewRoomView}.
    Diese View dient dazu neue Räume zu erstellen und User zu diesen einzuladen.
    Hierzu wird dem User wie in Abbildung~\ref{fig:newroomview} zu sehen, ein Textfeld gezeigt über welches er nach anderen Usern über deren Anzeigenamen oder ihre MatriID suchen kann.
    In der sich in der Unteren hälfte befindlichen scrollbaren Liste werden bis zu 10 Nutzer gezeigt die dem eingegebenen Suchtext entsprechen.
    Diese Funktion ist nur möglich falls in der Konfiguration des Homeservers die suche im Nutzerverzeichnis freigegeben ist.
    Die Konfiguration des Homeservers ist in Abschnitt~\ref{sec:homeserver} genauer beschrieben.
    Ist diese Funktion nicht freigegeben muss der User die vollständige MatrixID des gesuchten Nutzers angeben.
    Hat der User den von ihm gesuchen Nutzer gefunden kann er durch anklicken dem zu erstellenden Raum hinzufügen.
    Der Nutzer erscheint dann in der horizontal scrollbaren Liste von Usern.
    Hat der User einen falschen Nutzer zum Raum hinzugefügt kann er diesen durch antippen des Users in der Liste hinzugefügter Nutzer wieder entfernen.
    Hierbei achtet die App darauf, dass ein Nutzer nicht doppelt hinzugefügt werden kann.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{newroom}
        \centering
        \caption{NewRoomView}\label{fig:newroomview}
    \end{figure}

    Hat der User alle von ihm gewünschten Nutzer dem Raum hinzugefügt kann er diesen durch klicken auf den "Create"-Button erstellen.
    Die App entscheidet dann automatisch anhand der Anzahl der eingeladenen Usern ob ein direkter Raum erstellt werden soll oder nicht.
    Nach erstellen der Raumes wird automatisch ein StateEvent von Typ \texttt{.roomEncryption} an den Raum gesendet, welche die anderen Nutzer im Raum darüber informiert das Nachrichten in diesem Raum verschlüsselt zu senden sind.
    Der vollständige Vorgang zum verschlüsseln der Nachrichten ist in Abschnitt~\ref{subsec:verschlusselung-der-nachrichten} beschrieben.
    War das erstellen der Raumes erfolgreich wird der User in die \texttt{ChatView} des neu angelegten Raumes geleitet.

    \newpage
    \subsection{Chatfenster}
    Die in Abbildung~\ref{fig:chatview} gezeigte \texttt{ChatView} ist eine weitere Kernansicht der App.
    Sie ermöglicht es dem User Konversationen eines Raumes einzusehen und neue Nachrichten an diesen zu senden.
    Die Abbildung zeigt Beispielnachrichten für alle unterstützten Nachrichtentypen.
    Es können einfache Textnachrichten versendet werden, Fotos welche durch antippen in einem Fullscreen \texttt{ImageViewer} angezeigt werden,
    PDF-Dateien welche in einem \texttt{PDFViewer} eingesehen werden können, und Videos welche mittels \texttt{AZVideoPlayer} abgespielt werden können.
    Der Videoplayer unterstützt sowohl das abspielen direkt in der \texttt{ChatView} als auch im Fullscreenmode, sowohl im Landscape- als auch im Portrait-format.

    \begin{figure}[h]
        \includegraphics[scale=0.5]{chat}
        \centering
        \caption{ChatView}\label{fig:chatview}
    \end{figure}

    Des weiteren wird dem User ein Typing-Indikator gezeigt welcher der User darüber informiert ob der Gesprächspartner (oder in Multiuser Räumen welche Gesprächspartner) gerade eine Nachricht schreiben.
    Im Fuß der Ansicht befindet sich das Nachrichtenfenster über welches Nachrichten verfasst und an der Raum gesendet werden können.
    Durch klicken des Bild-Icons öffnet sich ein \texttt{ImagePicker} über welchen sowohl Fotos als auch Videos aus der Galerie gewählt und an den Raum gesendet werden können.
    Das Kamera-Icon daneben öffnet eine Kamera Ansicht über welche Fotos und videos direkt aus der App aufgenommen und versendet werden können.
    Über das Büroklammer-Icon lassen sich Dateien die auf dem Gerät gespeichert sind durchsuchen und an den Raum senden.
    Da nur Dateien vom Typ PDF von der App unterstützt werden wird im Datei Picker ebenfalls nach PDF gefiltert.
    Im Kopf der Ansicht erkennt man eine Hinweismeldung darauf, dass man das Ende der geladenen Nachrichten erreicht hat und nach unten wischen muss um weitere Nachrichten zu laden.
    Bei öffnen der \texttt{ChatView} werden sofern vorhanden 25 Nachrichten geladen.
    Dies geschieht mittels pagination der Matrix Timeline eines Raumes.
    Bei jedem weiteren laden von Nachrichten werden 25 weitere Nachrichten geladen und angezeigt.
    Es muss darauf geachtet werden, dass die Reihenfolge der Nachrichten ordnungsgemäß angezeigt wird.
    Die Lazy-Loading-Methode erlaubt hierbei eine angemessene Performance beim öffnen des Chats.
    Eine besondere Herausforderung ist die Position der scrollbaren Liste.
    Beim öffnen der View muss an das Ende der Liste gesprungen werden, da sich dort die neusten Nachrichten befinden.
    Falls eine neue Nachricht eintrifft während die View geöffnet ist springt die Liste ebenfalls an das Ende um dem Nutzer die neuste Nachricht anzuzeigen.
    Beim Laden älterer Nachrichten soll jedoch nicht zum Ende gesprungen werden.
    Über die drei Punkte in der oberen rechten Ecke der Ansicht öffnet sich ein Drop-Down-Menu über welches ein Raum verlassen werden kann oder sich eine Übersicht über den aktuellen Raum öffnet, wo Titel, Beschreibung und Bild des Raumes geändert werden können.
    Darüber hinaus zeigt sie einige Informationen über den Raum an wie die Anzahl an Teilnehmern, den Ersteller des Raumes und ob die Verschlüsselung aktiv ist.

    \newpage
    \subsection{Profile}\label{subsec:profile}
    Die \texttt{ProfileView} dient dazu

    \begin{figure}[h]
        \includegraphics[scale=0.5]{profile}
        \centering
        \caption{ProfileView}\label{fig:profileview}
    \end{figure}

    \begin{figure}[h]
        \centering
        \begin{sequencediagram}
            \newthread{A}{Client}{}
            \newinst[7]{B}{Server}{}
            \begin{sdblock}{Stage 1}{Receive Session ID}
                \begin{call}{A}{getLoginSession()}{B}{\shortstack{
                    return Session ID\\
                    return supported flows}}
                    \postlevel
                \end{call}
            \end{sdblock}
            \begin{sdblock}{Stage 2}{m.login.password}
                \begin{call}{A}{deactivateAccount()}{B}{}
                \end{call}
            \end{sdblock}
        \end{sequencediagram}
        \caption{Account löschen Flow}\label{fig:figure}
    \end{figure}

%    \subsection{Start der Matrix Session}\label{sec:start-der-matrix-session}

    \subsection{Verschlüsselung der Nachrichten}\label{subsec:verschlusselung-der-nachrichten}
    Zur Verschlüsselung der Nachrichten sind mehrere Schritte notending.
    Zuerset muss die Verschlüsselung in der Sitzung aktiviert werden.
    Dies geschieht durch starten und aktivieren des Crypto Modules der SDK.
    Dabei werden die im Abschnitt~\ref{subsec:verwendete-schlussel} aufgeführten Schlüssel erstellt und mit dem Server synchronisiert.
    Zusätzlich mus beim erstellen eines Raumes zuallererst ein encryption Event gesendet werden, welches die anderen Teilnehmer eines Raums darüber informiert, dass die Kommunikation in einem Raum verschlüsselt zu erfolgen hat.
    Hierbei muss der für die Verschlüssleung der Nachricht verwendete Algorithmus angegeben werden.
    Zur Zeit wird nur die \texttt{m.megolm.v1.aes-sha2} Verschlüsselung von der SDK unterstützt.
    Falls nun eine Nachricht über die Sitzung an den erstellten Raum gesendet wird, wird diese beim senden automatisch von der SDK verschlüsselt.
    Beim Empfangen von Nachrichten wird das Event ebenfalls automatisch entschlüsselt.
    Bei Fotos, Videos und Datein ist zu beachten, dass das Event lediglich einen Pfad zum Ablageort der gesendeten Datei auf dem Server enthält.
    Dieser Pfad muss nun übersetzt werden und anschließend heruntergeladen werden.
    Da die Dateien nach dem herunterladen noch immer verschlüsselt sind müssen diese anschließend mit der von der SDK bereitgestellten Funktion \texttt{MXEncryptedAttachments.decryptAttachment()} separat entschlüsselt werden.
    Anhand der Notwendigkeit des entschlüsselns der Dateien kann bestätigt werden, dass die Verschlüsslung aktiv ist.
    Zusätzlich kann auf dem Homeserver unter \texttt{/data/media\_store} geprüfte werden, dass die Dateien verschlüsselt auf dem Server abgelegt werden.

    \subsection{Benachrichtigungen}\label{subsec:benachrichtigungen}


    \newpage
    \section{Homeserver}\label{sec:homeserver}
    Der Homeserver bildet die unterliegende Infrastruktur der Plattform.
    Hierzu wird die vom Matrix Team bereitgestellte Synapse Software.
    Diese wird auf mittels eines Docker Containers auf dem Server betrieben.
    Bevor der Container gestartet werden einige Konfigurationsdateien benötigt welche über folgenden Befehl generiert werden können:
    \begin{lstlisting}[language=bash,label={lst:synapse-generate}]
        docker run -it --rm -v /path/on/host/machine/:/data -e SYNAPSE_SERVER_NAME=my.matrix.host -e SYNAPSE_REPORT_STATS=yes matrixdotorg/synapse:latest generate
    \end{lstlisting}
    Um später einfacher Änderungen an der Konfiguration des Homeservers vornehmen zu können wird das \texttt{/data} Directory im Host gemounted.
    Des weiteren muss der Name des Homeservers über \texttt{SYNAPSE\_SERVER\_NAME} definiert werden.
    Dieser wird später für die Identifikation des Homeservers genutzt.
    Nach ausführen des Befehls werden 3 Dateien generiert:
    \begin{description}[leftmargin=!,labelwidth=4cm]
        \item [homeserver.yaml] Konfigurationsdatei des Homeservers. Hier können alle Funktionalitätet des Homeservers konfiguriert werden.
        \item [my.matrix.host.log.config] Konfigurationsdatei des Loggers. Hier kann das Fromat für Log-Messages definiert werden und weitere
        \item [my.matrix.host.signing.key] Key zur Authentifizierung bei anderen Homeservern
    \end{description}

    Der \texttt{my.matrix.host.signing.key} wird für diese Implementation nicht benötigt, da der einzeln läuft und nicht an das Matrix Netzwerk angeschlossen wird.
    Bevor der Server gestartet wird sollten noch einige Konfigurationen angepasst werden:
    \begin{enumerate}[label={(\arabic*)}]
        \item Standardmäßig wird nur ein Listener auf Port 8008 für ungeschützte Verbindungen über HTTP konfiguriert.
                Um die App mit dem Homeserver verbinden zu können muss ein zusätzlicher HTTPS Listener auf Port 443 konfiguriert werden.
            \begin{lstlisting}[language=yaml,label={lst:listener}]
listeners:
  - port: 443
    type: http
    tls: true
    resources:
          - names: [client, federation]
            \end{lstlisting}
        \item Für den zusätzlichen Listener über HTTPS muss ein SSL Zertifikat erstellt werden und in der Konfiguration hinterlegt werden.
            \begin{lstlisting}[language=yaml,label={lst:ssl-certificate}]
tls_certificate_path: "/data/certs/cert.pem"
tls_private_key_path: "data/certs/key.pem"
            \end{lstlisting}
        \item Da der Server nicht mit dem Matrix Netzwerk verbunden wird muss die Key Verifizierung über den Matrix Root Server deaktiviert werden.
            \begin{lstlisting}[language=yaml,label={lst:disable-key-verification}]
federation_verify_certificates: false
trusted_key_servers:
  - server_name: "matrix.org"
    accept_keys_insecurely: true
    enable_registration_without_verification: true
            \end{lstlisting}
        \item Um das in Abschnitt~\ref{subsec:raumerzeugung} beschriebene durchsuchen des Nutzerverzeichnisses zu ermöglichen muss dies hier erlaubt werden.
            \begin{lstlisting}[language=yaml,label={lst:user-directory}]
user_directory:
  enabled: true
  search_all_users: true
            \end{lstlisting}
        \item Zusätzlich können Regeln aktiviert werden die beim Erstellen eines Account Prüfen ob das Passwort den gewünschten Richtlinien entspricht.
                Hier kann definiert werden welche Arten von Zeichen im Passwort enthalten sein müssen und wie lang das Passwort mindestens sein muss.
            \begin{lstlisting}[language=yaml,label={lst:password-policy}]
password_config:
   enabled: true
   localdb_enabled: true
   pepper: "EVEN_MORE_SECRET"

   policy:
      enabled: true
      minimum_length: 8
      require_digit: true
      require_symbol: true
      require_lowercase: true
      require_uppercase: true
            \end{lstlisting}
        \item Da die Registrierung nur mit einem Registrierungstoken möglich sein soll muss dies ebenfalls angegeben werden.
        \begin{lstlisting}[language=yaml,label={lst:enable-registration}]
enable_registration: true
registration_requires_token: true
        \end{lstlisting}
    \end{enumerate}
    Ein Beispiel für die Konfiguration des Homeservers kann dem Anhang entnommen werden.

    Nachdem alle Konfigurationen getätigt wurden kann der Homeserver gestartet werden.
    Es ist darauf zu achten, dass alle benötigten Ports des Containers auf dem Host gemapped werden.

    \begin{lstlisting}[language=bash,label={lst:synapse-start}]
        docker run -d --name synapse -v /path/on/host/machine/:/data -p 8008:8008 -p 443:443 matrixdotorg/synapse:latest
    \end{lstlisting}

    Nun ist der Homeserver einsatzbereit und Client können eine Verbindung aufnehmen.

    \newpage
    \chapter{Evaluation}\label{ch:evaluation}


    \chapter{Fazit}\label{ch:fazit}
    Die Plattform erfüllt die grundlegenden Anforderungen welche man an eine Messanger-App hat.
    Sie erlaubt es dem Benutzer einen Account anzulegen verhindert dabei aber gleichzeitig eine Überschwemmung der Plattform mit Accounts durch unkontrolliertes
    Zwar wurde während der Implementierung darauf geachtet, dass jegliche Daten zwischen Arzt und Patient verschlüsselt und vor unbefugtem Zugriff geschützt sind, jedoch müsste die genaue Rechtslage zum Einsatz der Plattform genauer untersucht werden.
    Das Userinterface der App erfüllt zwar die gesetzten Ansprüche jedoch lässt das Design noch deutlich Platz für Verbesserungen.
    Alle im Kapitel~\ref{sec:anforderungen} als 'Must' definierten Funktionen sind implementiert.
    Ebenfalls wurden alle Anforderungen aus der

    \chapter{Ausblick}\label{ch:ausblick}
    Der nächste Schritt in der Entwicklung der Plattform sollte es sein die Cross-Signing-Funktion der End-to-End Verschlüsslung zu unterstützen.
    Hierzu muss ein geeignetes Key-Management-System implementiert werden welches es ermöglicht ein Gerät von einem anderen zu verifizieren und die Private Keys die zur Verschlüsselung der Nachrichten verwendet wurden zwischen den Geräten zu synchronisieren.
    Darüber hinaus sollte eine Prozess implementiert werden der es ermöglicht auch ohne Zugriff auf eines der anderen Geräte die verwendeten Schlüssel wiederherzustellen.
    Somit könnte beispielsweise bei Verlust oder bei Beschädigung des Gerätes trotzdem noch auf bestehende Chat-Verläufe zugegriffen werden.
    Mittels des Recovery Services des Crypto Moduls kann ein Backup der Session Keys auf der Server angelegt werden, welches über einen Recovery Key oder eine Passphrase geschützt werden kann.
    Von diesem Backup können dann bei Bedarf alle gespeicherten Keys wiederhergestellt werden.
    Die Dokumentation hierfür ist noch in der Erstellung~\cite{advancede2e} was die Implementation zum aktuellen Zeitpunkt deutlich erschwert.\\
    Des weiteren kann die Plattform um zusätzliche Nachrichtentypen erweitert werden.
    Es könnte beispielsweise das Aufnehmen und versenden von Audiodateien hinzugefügt werden.
    Außerdem kann der Datei-Message-Typ um weiter Dateitypen erweitert werden.

%    Außerdem könnte ein zusätzlicher Layer implementiert werden, welcher es ermöglicht Informationen über beigetretene Räume und deren jeweilige Konversationen geschützt auf dem Gerät zu speichern.
%    Somit hat der User auch ohne bestehende Verbindung zum Internet, Zugriff auf seine Konversationen und mögliche geteilter Daten.
%    Ferner sollten zusätzliche Dateitypen für Nachrichten unterstützt werden um es
%
%    Des weiteren könnte untersucht werden ob der Synapse Server in der LAge ist den Registrierungstoken über einen SMTP Server direkt an den User zu schicken nach vorheriger angabe einer emailadresse.

%\include{source/content/Test}

%Das Fazit
%\include{source/content/Fazit}
%Einbinden des Abbildungsverzeichnisses

    \backmatter
%Liste der Tabellen
%    \listoftables
%Einbinden des Tabellenverzeichnisses
    \listoffigures
%Einbinden des Sourcecodeverzeichnisses
%\lstlistoflistings

% Quellenverzeichnis
    \bibliographystyle{abbrvnat}
    \bibliography{Bachelorarbeit}

% Anhang
    \appendix

\end{document}



%
% EOF
%